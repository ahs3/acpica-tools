Big-endian support

This is a combined patch that folds all of the past and present changes
for big-endian support into a single patch, hopefully eliminating any sort
of redundancy but also capturing all such changes in a single location.

To date, this has been critical for the s390x architecture only.

Signed-off-by: Al Stone <ahs3@redhat.com>

Index: acpica-unix-20191213/source/compiler/aslcodegen.c
===================================================================
--- acpica-unix-20191213.orig/source/compiler/aslcodegen.c
+++ acpica-unix-20191213/source/compiler/aslcodegen.c
@@ -237,16 +237,12 @@ CgWriteAmlOpcode (
     ACPI_PARSE_OBJECT       *Op)
 {
     UINT8                   PkgLenFirstByte;
-    UINT32                  i;
-    union {
-        UINT16                  Opcode;
-        UINT8                   OpcodeBytes[2];
-    } Aml;
-    union {
-        UINT32                  Len;
-        UINT8                   LenBytes[4];
-    } PkgLen;
-
+    UINT8                   Byte;
+    UINT16                  Word;
+    UINT32                  DWord;
+    UINT64                  QWord;
+    UINT16                  AmlOpcode;
+    UINT32                  PkgLen;
 
     /* We expect some DEFAULT_ARGs, just ignore them */
 
@@ -279,51 +275,52 @@ CgWriteAmlOpcode (
 
         /* Special opcodes for within a field definition */
 
-        Aml.Opcode = AML_FIELD_OFFSET_OP;
+        AmlOpcode = AML_FIELD_OFFSET_OP;
         break;
 
     case AML_INT_ACCESSFIELD_OP:
 
-        Aml.Opcode = AML_FIELD_ACCESS_OP;
+        AmlOpcode = AML_FIELD_ACCESS_OP;
         break;
 
     case AML_INT_CONNECTION_OP:
 
-        Aml.Opcode = AML_FIELD_CONNECTION_OP;
+        AmlOpcode = AML_FIELD_CONNECTION_OP;
         break;
 
     default:
 
-        Aml.Opcode = Op->Asl.AmlOpcode;
+        AmlOpcode = Op->Asl.AmlOpcode;
         break;
     }
 
 
-    switch (Aml.Opcode)
+    switch (AmlOpcode)
     {
     case AML_PACKAGE_LENGTH:
 
         /* Value is the length to be encoded (Used in field definitions) */
 
-        PkgLen.Len = (UINT32) Op->Asl.Value.Integer;
+        PkgLen = (UINT32) Op->Asl.Value.Integer;
         break;
 
     default:
 
         /* Check for two-byte opcode */
 
-        if (Aml.Opcode > 0x00FF)
+        if (AmlOpcode > 0x00FF)
         {
             /* Write the high byte first */
-
-            CgLocalWriteAmlData (Op, &Aml.OpcodeBytes[1], 1);
+	    Byte = ACPI_HIBYTE(AmlOpcode);
+	    CgLocalWriteAmlData (Op, &Byte, 1);
         }
 
-        CgLocalWriteAmlData (Op, &Aml.OpcodeBytes[0], 1);
+	Byte = ACPI_LOBYTE(AmlOpcode);
+        CgLocalWriteAmlData (Op, &Byte, 1);
 
         /* Subtreelength doesn't include length of package length bytes */
 
-        PkgLen.Len = Op->Asl.AmlSubtreeLength + Op->Asl.AmlPkgLenBytes;
+        PkgLen = Op->Asl.AmlSubtreeLength + Op->Asl.AmlPkgLenBytes;
         break;
     }
 
@@ -334,8 +331,8 @@ CgWriteAmlOpcode (
         if (Op->Asl.AmlPkgLenBytes == 1)
         {
             /* Simplest case -- no bytes to follow, just write the count */
-
-            CgLocalWriteAmlData (Op, &PkgLen.LenBytes[0], 1);
+            Byte = ACPI_LOBYTE(PkgLen);
+            CgLocalWriteAmlData (Op, &Byte, 1);
         }
         else if (Op->Asl.AmlPkgLenBytes != 0)
         {
@@ -345,7 +342,7 @@ CgWriteAmlOpcode (
              */
             PkgLenFirstByte = (UINT8)
                 (((UINT32) (Op->Asl.AmlPkgLenBytes - 1) << 6) |
-                (PkgLen.LenBytes[0] & 0x0F));
+                (PkgLen & 0x0F));
 
             CgLocalWriteAmlData (Op, &PkgLenFirstByte, 1);
 
@@ -353,39 +350,47 @@ CgWriteAmlOpcode (
              * Shift the length over by the 4 bits we just stuffed
              * in the first byte
              */
-            PkgLen.Len >>= 4;
+            PkgLen >>= 4;
 
             /*
              * Now we can write the remaining bytes -
              * either 1, 2, or 3 bytes
              */
-            for (i = 0; i < (UINT32) (Op->Asl.AmlPkgLenBytes - 1); i++)
+            Byte = ACPI_LOBYTE(PkgLen);
+            CgLocalWriteAmlData (Op, &Byte, 1);
+            if (Op->Asl.AmlPkgLenBytes >= 3)
+            {
+                Byte = ACPI_HIBYTE(PkgLen);
+                CgLocalWriteAmlData (Op, &Byte, 1);
+            }
+            if (Op->Asl.AmlPkgLenBytes >= 4)
             {
-                CgLocalWriteAmlData (Op, &PkgLen.LenBytes[i], 1);
+                Byte = ACPI_LOBYTE(ACPI_HIWORD(PkgLen));
+                CgLocalWriteAmlData (Op, &Byte, 1);
             }
         }
     }
 
-    switch (Aml.Opcode)
+    switch (AmlOpcode)
     {
     case AML_BYTE_OP:
-
-        CgLocalWriteAmlData (Op, &Op->Asl.Value.Integer, 1);
+        Byte = (UINT8) Op->Asl.Value.Integer;
+        CgLocalWriteAmlData (Op, &Byte, 1);
         break;
 
     case AML_WORD_OP:
-
-        CgLocalWriteAmlData (Op, &Op->Asl.Value.Integer, 2);
+        ACPI_MOVE_64_TO_16(&Word, &Op->Asl.Value.Integer);
+        CgLocalWriteAmlData (Op, &Word, 2);
        break;
 
     case AML_DWORD_OP:
-
-        CgLocalWriteAmlData (Op, &Op->Asl.Value.Integer, 4);
+        ACPI_MOVE_64_TO_32(&DWord, &Op->Asl.Value.Integer);
+        CgLocalWriteAmlData (Op, &DWord, 4);
         break;
 
     case AML_QWORD_OP:
-
-        CgLocalWriteAmlData (Op, &Op->Asl.Value.Integer, 8);
+        ACPI_MOVE_64_TO_64(&QWord, &Op->Asl.Value.Integer);
+        CgLocalWriteAmlData (Op, &QWord, 8);
         break;
 
     case AML_STRING_OP:
@@ -421,6 +426,7 @@ CgWriteTableHeader (
     ACPI_PARSE_OBJECT       *Op)
 {
     ACPI_PARSE_OBJECT       *Child;
+    UINT32                  DWord;
     UINT32                  CommentLength;
     ACPI_COMMENT_NODE       *Current;
 
@@ -478,7 +484,7 @@ CgWriteTableHeader (
     /* OEM Revision */
 
     Child = Child->Asl.Next;
-    AslGbl_TableHeader.OemRevision = (UINT32) Child->Asl.Value.Integer;
+    ACPI_MOVE_64_TO_32(&AslGbl_TableHeader.OemRevision, &Child->Asl.Value.Integer);
 
     /* Compiler ID */
 
@@ -486,12 +492,13 @@ CgWriteTableHeader (
 
     /* Compiler version */
 
-    AslGbl_TableHeader.AslCompilerRevision = ACPI_CA_VERSION;
+    DWord = ACPI_CA_VERSION;
+    ACPI_MOVE_32_TO_32(&AslGbl_TableHeader.AslCompilerRevision, &DWord);
 
     /* Table length. Checksum zero for now, will rewrite later */
 
-    AslGbl_TableHeader.Length = sizeof (ACPI_TABLE_HEADER) +
-        Op->Asl.AmlSubtreeLength;
+    DWord = sizeof (ACPI_TABLE_HEADER) + Op->Asl.AmlSubtreeLength;
+    ACPI_MOVE_32_TO_32(&AslGbl_TableHeader.Length, &DWord);
 
     /* Calculate the comment lengths for this definition block parseOp */
 
@@ -625,7 +632,10 @@ CgWriteNode (
     ACPI_PARSE_OBJECT       *Op)
 {
     ASL_RESOURCE_NODE       *Rnode;
-
+    UINT8                   Byte;
+    UINT16                  Word;
+    UINT32                  DWord;
+    UINT64                  QWord;
 
     /* Write all comments here. */
 
@@ -649,13 +659,24 @@ CgWriteNode (
     switch (Op->Asl.AmlOpcode)
     {
     case AML_RAW_DATA_BYTE:
+        Byte = (UINT8) Op->Asl.Value.Integer;
+        CgLocalWriteAmlData (Op, &Byte, 1);
+        return;
+
     case AML_RAW_DATA_WORD:
-    case AML_RAW_DATA_DWORD:
-    case AML_RAW_DATA_QWORD:
+        ACPI_MOVE_64_TO_16(&Word, &Op->Asl.Value.Integer);
+        CgLocalWriteAmlData (Op, &Word, 2);
+        return;
 
-        CgLocalWriteAmlData (Op, &Op->Asl.Value.Integer, Op->Asl.AmlLength);
+    case AML_RAW_DATA_DWORD:
+        ACPI_MOVE_64_TO_32(&DWord, &Op->Asl.Value.Integer);
+        CgLocalWriteAmlData (Op, &DWord, 4);
         return;
 
+    case AML_RAW_DATA_QWORD:
+        ACPI_MOVE_64_TO_64(&QWord, &Op->Asl.Value.Integer);
+        CgLocalWriteAmlData (Op, &QWord, 8);
+        return;
 
     case AML_RAW_DATA_BUFFER:
 
Index: acpica-unix-20191213/source/compiler/aslopcodes.c
===================================================================
--- acpica-unix-20191213.orig/source/compiler/aslopcodes.c
+++ acpica-unix-20191213/source/compiler/aslopcodes.c
@@ -485,6 +485,7 @@ OpcDoUnicode (
     UINT32                  i;
     UINT8                   *AsciiString;
     UINT16                  *UnicodeString;
+    UINT16                  UChar;
     ACPI_PARSE_OBJECT       *BufferLengthOp;
 
 
@@ -511,7 +512,8 @@ OpcDoUnicode (
 
     for (i = 0; i < Count; i++)
     {
-        UnicodeString[i] = (UINT16) AsciiString[i];
+        UChar = (UINT16) AsciiString[i];
+        ACPI_MOVE_16_TO_16(&UnicodeString[i], &UChar);
     }
 
     /*
Index: acpica-unix-20191213/source/compiler/aslrestype1.c
===================================================================
--- acpica-unix-20191213.orig/source/compiler/aslrestype1.c
+++ acpica-unix-20191213/source/compiler/aslrestype1.c
@@ -142,6 +142,11 @@ RsDoMemory24Descriptor (
     ACPI_PARSE_OBJECT       *LengthOp = NULL;
     ASL_RESOURCE_NODE       *Rnode;
     UINT32                  CurrentByteOffset;
+    UINT16                  Minimum = 0;
+    UINT16                  Maximum = 0;
+    UINT16                  AddressLength = 0;
+    UINT16                  Alignment = 0;
+    UINT16                  ResourceLength;
     UINT32                  i;
 
 
@@ -151,7 +156,8 @@ RsDoMemory24Descriptor (
 
     Descriptor = Rnode->Buffer;
     Descriptor->Memory24.DescriptorType = ACPI_RESOURCE_NAME_MEMORY24;
-    Descriptor->Memory24.ResourceLength = 9;
+    ResourceLength = 9;
+    ACPI_MOVE_16_TO_16(&Descriptor->Memory24.ResourceLength, &ResourceLength);
 
     /* Process all child initialization nodes */
 
@@ -168,7 +174,7 @@ RsDoMemory24Descriptor (
 
         case 1: /* Min Address */
 
-            Descriptor->Memory24.Minimum = (UINT16) InitializerOp->Asl.Value.Integer;
+            Minimum = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_MINADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Memory24.Minimum));
             MinOp = InitializerOp;
@@ -176,7 +182,7 @@ RsDoMemory24Descriptor (
 
         case 2: /* Max Address */
 
-            Descriptor->Memory24.Maximum = (UINT16) InitializerOp->Asl.Value.Integer;
+            Maximum = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_MAXADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Memory24.Maximum));
             MaxOp = InitializerOp;
@@ -184,14 +190,14 @@ RsDoMemory24Descriptor (
 
         case 3: /* Alignment */
 
-            Descriptor->Memory24.Alignment = (UINT16) InitializerOp->Asl.Value.Integer;
+            Alignment = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_ALIGNMENT,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Memory24.Alignment));
             break;
 
         case 4: /* Length */
 
-            Descriptor->Memory24.AddressLength = (UINT16) InitializerOp->Asl.Value.Integer;
+            AddressLength = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_LENGTH,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Memory24.AddressLength));
             LengthOp = InitializerOp;
@@ -214,12 +220,17 @@ RsDoMemory24Descriptor (
     /* Validate the Min/Max/Len/Align values (Alignment==0 means 64K) */
 
     RsSmallAddressCheck (ACPI_RESOURCE_NAME_MEMORY24,
-        Descriptor->Memory24.Minimum,
-        Descriptor->Memory24.Maximum,
-        Descriptor->Memory24.AddressLength,
-        Descriptor->Memory24.Alignment,
+        Minimum,
+        Maximum,
+        AddressLength,
+        Alignment,
         MinOp, MaxOp, LengthOp, NULL, Info->DescriptorTypeOp);
 
+    ACPI_MOVE_16_TO_16(&Descriptor->Memory24.Minimum, &Minimum);
+    ACPI_MOVE_16_TO_16(&Descriptor->Memory24.Maximum, &Maximum);
+    ACPI_MOVE_16_TO_16(&Descriptor->Memory24.AddressLength, &AddressLength);
+    ACPI_MOVE_16_TO_16(&Descriptor->Memory24.Alignment, &Alignment);
+
     return (Rnode);
 }
 
@@ -248,6 +259,11 @@ RsDoMemory32Descriptor (
     ACPI_PARSE_OBJECT       *AlignOp = NULL;
     ASL_RESOURCE_NODE       *Rnode;
     UINT32                  CurrentByteOffset;
+    UINT32                  Minimum = 0;
+    UINT32                  Maximum = 0;
+    UINT32                  AddressLength = 0;
+    UINT32                  Alignment = 0;
+    UINT16                  ResourceLength;
     UINT32                  i;
 
 
@@ -257,7 +273,8 @@ RsDoMemory32Descriptor (
 
     Descriptor = Rnode->Buffer;
     Descriptor->Memory32.DescriptorType = ACPI_RESOURCE_NAME_MEMORY32;
-    Descriptor->Memory32.ResourceLength = 17;
+    ResourceLength = 17;
+    ACPI_MOVE_16_TO_16(&Descriptor->Memory32.ResourceLength, &ResourceLength);
 
     /* Process all child initialization nodes */
 
@@ -274,7 +291,7 @@ RsDoMemory32Descriptor (
 
         case 1:  /* Min Address */
 
-            Descriptor->Memory32.Minimum = (UINT32) InitializerOp->Asl.Value.Integer;
+            Minimum = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_MINADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Memory32.Minimum));
             MinOp = InitializerOp;
@@ -282,7 +299,7 @@ RsDoMemory32Descriptor (
 
         case 2: /* Max Address */
 
-            Descriptor->Memory32.Maximum = (UINT32) InitializerOp->Asl.Value.Integer;
+            Maximum = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_MAXADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Memory32.Maximum));
             MaxOp = InitializerOp;
@@ -290,7 +307,7 @@ RsDoMemory32Descriptor (
 
         case 3: /* Alignment */
 
-            Descriptor->Memory32.Alignment = (UINT32) InitializerOp->Asl.Value.Integer;
+            Alignment = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_ALIGNMENT,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Memory32.Alignment));
             AlignOp = InitializerOp;
@@ -298,7 +315,7 @@ RsDoMemory32Descriptor (
 
         case 4: /* Length */
 
-            Descriptor->Memory32.AddressLength = (UINT32) InitializerOp->Asl.Value.Integer;
+            AddressLength = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_LENGTH,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Memory32.AddressLength));
             LengthOp = InitializerOp;
@@ -321,12 +338,17 @@ RsDoMemory32Descriptor (
     /* Validate the Min/Max/Len/Align values */
 
     RsSmallAddressCheck (ACPI_RESOURCE_NAME_MEMORY32,
-        Descriptor->Memory32.Minimum,
-        Descriptor->Memory32.Maximum,
-        Descriptor->Memory32.AddressLength,
-        Descriptor->Memory32.Alignment,
+        Minimum,
+        Maximum,
+        AddressLength,
+        Alignment,
         MinOp, MaxOp, LengthOp, AlignOp, Info->DescriptorTypeOp);
 
+    ACPI_MOVE_32_TO_32(&Descriptor->Memory32.Minimum, &Minimum);
+    ACPI_MOVE_32_TO_32(&Descriptor->Memory32.Maximum, &Maximum);
+    ACPI_MOVE_32_TO_32(&Descriptor->Memory32.AddressLength, &AddressLength);
+    ACPI_MOVE_32_TO_32(&Descriptor->Memory32.Alignment, &Alignment);
+
     return (Rnode);
 }
 
@@ -351,6 +373,7 @@ RsDoMemory32FixedDescriptor (
     ACPI_PARSE_OBJECT       *InitializerOp;
     ASL_RESOURCE_NODE       *Rnode;
     UINT32                  CurrentByteOffset;
+    UINT16                  ResourceLength;
     UINT32                  i;
 
 
@@ -360,7 +383,8 @@ RsDoMemory32FixedDescriptor (
 
     Descriptor = Rnode->Buffer;
     Descriptor->FixedMemory32.DescriptorType = ACPI_RESOURCE_NAME_FIXED_MEMORY32;
-    Descriptor->FixedMemory32.ResourceLength = 9;
+    ResourceLength = 9;
+    ACPI_MOVE_16_TO_16(&Descriptor->FixedMemory32.ResourceLength, &ResourceLength);
 
     /* Process all child initialization nodes */
 
@@ -377,14 +401,16 @@ RsDoMemory32FixedDescriptor (
 
         case 1: /* Address */
 
-            Descriptor->FixedMemory32.Address = (UINT32) InitializerOp->Asl.Value.Integer;
+            ACPI_MOVE_64_TO_32(&Descriptor->FixedMemory32.Address,
+                &InitializerOp->Asl.Value.Integer);
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_BASEADDRESS,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (FixedMemory32.Address));
             break;
 
         case 2: /* Length */
 
-            Descriptor->FixedMemory32.AddressLength = (UINT32) InitializerOp->Asl.Value.Integer;
+            ACPI_MOVE_64_TO_32(&Descriptor->FixedMemory32.AddressLength,
+                &InitializerOp->Asl.Value.Integer);
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_LENGTH,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (FixedMemory32.AddressLength));
             break;
Index: acpica-unix-20191213/source/compiler/aslrestype1i.c
===================================================================
--- acpica-unix-20191213.orig/source/compiler/aslrestype1i.c
+++ acpica-unix-20191213/source/compiler/aslrestype1i.c
@@ -198,6 +198,8 @@ RsDoFixedDmaDescriptor (
     ACPI_PARSE_OBJECT       *InitializerOp;
     ASL_RESOURCE_NODE       *Rnode;
     UINT32                  CurrentByteOffset;
+    UINT16                  RequestLines = 0;
+    UINT16                  Channels = 0;
     UINT32                  i;
 
 
@@ -217,14 +219,14 @@ RsDoFixedDmaDescriptor (
         {
         case 0: /* DMA Request Lines [WORD] (_DMA) */
 
-            Descriptor->FixedDma.RequestLines = (UINT16) InitializerOp->Asl.Value.Integer;
+            RequestLines = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_DMA,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (FixedDma.RequestLines));
             break;
 
         case 1: /* DMA Channel [WORD] (_TYP) */
 
-            Descriptor->FixedDma.Channels = (UINT16) InitializerOp->Asl.Value.Integer;
+            Channels = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_DMATYPE,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (FixedDma.Channels));
             break;
@@ -249,6 +251,9 @@ RsDoFixedDmaDescriptor (
         InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
     }
 
+    ACPI_MOVE_16_TO_16(&Descriptor->FixedDma.RequestLines, &RequestLines);
+    ACPI_MOVE_16_TO_16(&Descriptor->FixedDma.Channels, &Channels);
+
     return (Rnode);
 }
 
@@ -274,6 +279,7 @@ RsDoFixedIoDescriptor (
     ACPI_PARSE_OBJECT       *AddressOp = NULL;
     ASL_RESOURCE_NODE       *Rnode;
     UINT32                  CurrentByteOffset;
+    UINT16                  Address = 0;
     UINT32                  i;
 
 
@@ -293,8 +299,7 @@ RsDoFixedIoDescriptor (
         {
         case 0: /* Base Address */
 
-            Descriptor->FixedIo.Address =
-                (UINT16) InitializerOp->Asl.Value.Integer;
+            Address = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_BASEADDRESS,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (FixedIo.Address));
             AddressOp = InitializerOp;
@@ -324,11 +329,13 @@ RsDoFixedIoDescriptor (
 
     /* Error checks */
 
-    if (Descriptor->FixedIo.Address > 0x03FF)
+    if (Address > 0x03FF)
     {
         AslError (ASL_WARNING, ASL_MSG_ISA_ADDRESS, AddressOp, NULL);
     }
 
+    ACPI_MOVE_16_TO_16(&Descriptor->FixedIo.Address, &Address);
+
     return (Rnode);
 }
 
@@ -357,6 +364,8 @@ RsDoIoDescriptor (
     ACPI_PARSE_OBJECT       *AlignOp = NULL;
     ASL_RESOURCE_NODE       *Rnode;
     UINT32                  CurrentByteOffset;
+    UINT16                  Minimum = 0;
+    UINT16                  Maximum = 0;
     UINT32                  i;
 
 
@@ -383,8 +392,7 @@ RsDoIoDescriptor (
 
         case 1:  /* Min Address */
 
-            Descriptor->Io.Minimum =
-                (UINT16) InitializerOp->Asl.Value.Integer;
+            Minimum = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_MINADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Io.Minimum));
             MinOp = InitializerOp;
@@ -392,8 +400,7 @@ RsDoIoDescriptor (
 
         case 2: /* Max Address */
 
-            Descriptor->Io.Maximum =
-                (UINT16) InitializerOp->Asl.Value.Integer;
+            Maximum = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_MAXADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Io.Maximum));
             MaxOp = InitializerOp;
@@ -434,12 +441,15 @@ RsDoIoDescriptor (
     /* Validate the Min/Max/Len/Align values */
 
     RsSmallAddressCheck (ACPI_RESOURCE_NAME_IO,
-        Descriptor->Io.Minimum,
-        Descriptor->Io.Maximum,
+        Minimum,
+        Maximum,
         Descriptor->Io.AddressLength,
         Descriptor->Io.Alignment,
         MinOp, MaxOp, LengthOp, AlignOp, Info->DescriptorTypeOp);
 
+    ACPI_MOVE_16_TO_16(&Descriptor->Io.Minimum, &Minimum);
+    ACPI_MOVE_16_TO_16(&Descriptor->Io.Maximum, &Maximum);
+
     return (Rnode);
 }
 
@@ -559,9 +569,9 @@ RsDoIrqDescriptor (
         InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
     }
 
-    /* Now we can set the channel mask */
+    /* Now we can set the interrupt mask */
 
-    Descriptor->Irq.IrqMask = IrqMask;
+    ACPI_MOVE_16_TO_16(&Descriptor->Irq.IrqMask, &IrqMask);
     return (Rnode);
 }
 
@@ -660,6 +670,6 @@ RsDoIrqNoFlagsDescriptor (
 
     /* Now we can set the interrupt mask */
 
-    Descriptor->Irq.IrqMask = IrqMask;
+    ACPI_MOVE_16_TO_16(&Descriptor->Irq.IrqMask, &IrqMask);
     return (Rnode);
 }
Index: acpica-unix-20191213/source/compiler/aslrestype2.c
===================================================================
--- acpica-unix-20191213.orig/source/compiler/aslrestype2.c
+++ acpica-unix-20191213/source/compiler/aslrestype2.c
@@ -76,6 +76,7 @@ RsDoGeneralRegisterDescriptor (
     ACPI_PARSE_OBJECT       *InitializerOp;
     ASL_RESOURCE_NODE       *Rnode;
     UINT32                  CurrentByteOffset;
+    UINT16                  ResourceLength;
     UINT32                  i;
 
 
@@ -85,7 +86,9 @@ RsDoGeneralRegisterDescriptor (
 
     Descriptor = Rnode->Buffer;
     Descriptor->GenericReg.DescriptorType = ACPI_RESOURCE_NAME_GENERIC_REGISTER;
-    Descriptor->GenericReg.ResourceLength = 12;
+    ResourceLength = 12;
+    ACPI_MOVE_16_TO_16(&Descriptor->GenericReg.ResourceLength,
+		    &ResourceLength);
 
     /* Process all child initialization nodes */
 
@@ -95,35 +98,52 @@ RsDoGeneralRegisterDescriptor (
         {
         case 0: /* Address space */
 
+	    /*
             Descriptor->GenericReg.AddressSpaceId = (UINT8) InitializerOp->Asl.Value.Integer;
+	    */
+            ACPI_MOVE_64_TO_8(&Descriptor->GenericReg.AddressSpaceId,
+			      &InitializerOp->Asl.Value.Integer);
             RsCreateByteField (InitializerOp, ACPI_RESTAG_ADDRESSSPACE,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (GenericReg.AddressSpaceId));
            break;
 
         case 1: /* Register Bit Width */
 
+	    /*
             Descriptor->GenericReg.BitWidth = (UINT8) InitializerOp->Asl.Value.Integer;
+	    */
+            ACPI_MOVE_64_TO_8(&Descriptor->GenericReg.BitWidth,
+			      &InitializerOp->Asl.Value.Integer);
             RsCreateByteField (InitializerOp, ACPI_RESTAG_REGISTERBITWIDTH,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (GenericReg.BitWidth));
             break;
 
         case 2: /* Register Bit Offset */
 
+	    /*
             Descriptor->GenericReg.BitOffset = (UINT8) InitializerOp->Asl.Value.Integer;
+	    */
+            ACPI_MOVE_64_TO_8(&Descriptor->GenericReg.BitOffset,
+			      &InitializerOp->Asl.Value.Integer);
             RsCreateByteField (InitializerOp, ACPI_RESTAG_REGISTERBITOFFSET,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (GenericReg.BitOffset));
             break;
 
         case 3: /* Register Address */
 
-            Descriptor->GenericReg.Address = InitializerOp->Asl.Value.Integer;
+	    ACPI_MOVE_64_TO_64(&Descriptor->GenericReg.Address,
+			    &InitializerOp->Asl.Value.Integer);
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_ADDRESS,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (GenericReg.Address));
             break;
 
         case 4: /* Access Size (ACPI 3.0) */
 
+	    /*
             Descriptor->GenericReg.AccessSize = (UINT8) InitializerOp->Asl.Value.Integer;
+	    */
+	    ACPI_MOVE_64_TO_8(&Descriptor->GenericReg.AccessSize,
+			      &InitializerOp->Asl.Value.Integer);
             RsCreateByteField (InitializerOp, ACPI_RESTAG_ACCESSSIZE,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (GenericReg.AccessSize));
 
@@ -177,6 +197,7 @@ RsDoInterruptDescriptor (
     AML_RESOURCE            *Rover = NULL;
     ACPI_PARSE_OBJECT       *InitializerOp;
     ASL_RESOURCE_NODE       *Rnode;
+    UINT16                  ResourceLength = 0;
     UINT16                  StringLength = 0;
     UINT32                  OptionIndex = 0;
     UINT32                  CurrentByteOffset;
@@ -225,7 +246,7 @@ RsDoInterruptDescriptor (
      * Initial descriptor length -- may be enlarged if there are
      * optional fields present
      */
-    Descriptor->ExtendedIrq.ResourceLength  = 2;  /* Flags and table length byte */
+    ResourceLength  = 2;  /* Flags and table length byte */
     Descriptor->ExtendedIrq.InterruptCount  = 0;
 
     Rover = ACPI_CAST_PTR (AML_RESOURCE,
@@ -333,10 +354,11 @@ RsDoInterruptDescriptor (
 
             /* Save the integer and move pointer to the next one */
 
-            Rover->DwordItem = (UINT32) InitializerOp->Asl.Value.Integer;
+            ACPI_MOVE_64_TO_32(&Rover->DwordItem,
+                &InitializerOp->Asl.Value.Integer);
             Rover = ACPI_ADD_PTR (AML_RESOURCE, &(Rover->DwordItem), 4);
             Descriptor->ExtendedIrq.InterruptCount++;
-            Descriptor->ExtendedIrq.ResourceLength += 4;
+            ResourceLength += 4;
 
             /* Case 7: First interrupt number in list */
 
@@ -372,7 +394,7 @@ RsDoInterruptDescriptor (
     {
         Rover->ByteItem = ResSourceIndex;
         Rover = ACPI_ADD_PTR (AML_RESOURCE, &(Rover->ByteItem), 1);
-        Descriptor->ExtendedIrq.ResourceLength += 1;
+        ResourceLength += 1;
     }
 
     /* Add optional ResSource string if present */
@@ -381,14 +403,15 @@ RsDoInterruptDescriptor (
     {
         strcpy ((char *) Rover, (char *) ResSourceString);
 
-        Descriptor->ExtendedIrq.ResourceLength = (UINT16)
-            (Descriptor->ExtendedIrq.ResourceLength + StringLength);
+        ResourceLength = (UINT16) (ResourceLength + StringLength);
     }
 
     Rnode->BufferLength =
         (ASL_RESDESC_OFFSET (ExtendedIrq.Interrupts[0]) -
         ASL_RESDESC_OFFSET (ExtendedIrq.DescriptorType))
         + OptionIndex + StringLength;
+    ACPI_MOVE_16_TO_16(&Descriptor->ExtendedIrq.ResourceLength,
+		    &ResourceLength);
     return (Rnode);
 }
 
@@ -436,7 +459,7 @@ RsDoVendorLargeDescriptor (
 
     Descriptor = Rnode->Buffer;
     Descriptor->VendorLarge.DescriptorType = ACPI_RESOURCE_NAME_VENDOR_LARGE;
-    Descriptor->VendorLarge.ResourceLength = (UINT16) i;
+    ACPI_MOVE_32_TO_16(&Descriptor->VendorLarge.ResourceLength, &i);
 
     /* Point to end-of-descriptor for vendor data */
 
Index: acpica-unix-20191213/source/compiler/aslrestype2d.c
===================================================================
--- acpica-unix-20191213.orig/source/compiler/aslrestype2d.c
+++ acpica-unix-20191213/source/compiler/aslrestype2d.c
@@ -79,7 +79,13 @@ RsDoDwordIoDescriptor (
     ACPI_PARSE_OBJECT       *GranOp = NULL;
     ASL_RESOURCE_NODE       *Rnode;
     UINT16                  StringLength = 0;
+    UINT16                  ResourceLength = 0;
     UINT32                  OptionIndex = 0;
+    UINT32                  Minimum = 0;
+    UINT32                  Maximum = 0;
+    UINT32                  AddressLength = 0;
+    UINT32                  Granularity = 0;
+    UINT32                  TranslationOffset = 0;
     UINT8                   *OptionalFields;
     UINT32                  CurrentByteOffset;
     UINT32                  i;
@@ -102,8 +108,7 @@ RsDoDwordIoDescriptor (
      * optional fields present
      */
     OptionalFields = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_ADDRESS32);
-    Descriptor->Address32.ResourceLength = (UINT16)
-        (sizeof (AML_RESOURCE_ADDRESS32) -
+    ResourceLength = (UINT16) (sizeof (AML_RESOURCE_ADDRESS32) -
          sizeof (AML_RESOURCE_LARGE_HEADER));
 
     /* Process all child initialization nodes */
@@ -147,8 +152,7 @@ RsDoDwordIoDescriptor (
 
         case 5: /* Address Granularity */
 
-            Descriptor->Address32.Granularity =
-                (UINT32) InitializerOp->Asl.Value.Integer;
+            Granularity = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Granularity));
             GranOp = InitializerOp;
@@ -156,8 +160,7 @@ RsDoDwordIoDescriptor (
 
         case 6: /* Address Min */
 
-            Descriptor->Address32.Minimum =
-                (UINT32) InitializerOp->Asl.Value.Integer;
+            Minimum = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_MINADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Minimum));
             MinOp = InitializerOp;
@@ -165,8 +168,7 @@ RsDoDwordIoDescriptor (
 
         case 7: /* Address Max */
 
-            Descriptor->Address32.Maximum =
-                (UINT32) InitializerOp->Asl.Value.Integer;
+            Maximum = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_MAXADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Maximum));
             MaxOp = InitializerOp;
@@ -174,16 +176,14 @@ RsDoDwordIoDescriptor (
 
         case 8: /* Translation Offset */
 
-            Descriptor->Address32.TranslationOffset =
-                (UINT32) InitializerOp->Asl.Value.Integer;
+            TranslationOffset = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.TranslationOffset));
             break;
 
         case 9: /* Address Length */
 
-            Descriptor->Address32.AddressLength =
-                (UINT32) InitializerOp->Asl.Value.Integer;
+            AddressLength = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_LENGTH,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.AddressLength));
             LengthOp = InitializerOp;
@@ -197,7 +197,7 @@ RsDoDwordIoDescriptor (
 
                 OptionalFields[0] = (UINT8) InitializerOp->Asl.Value.Integer;
                 OptionIndex++;
-                Descriptor->Address32.ResourceLength++;
+                ResourceLength++;
                 ResSourceIndex = TRUE;
             }
             break;
@@ -211,8 +211,7 @@ RsDoDwordIoDescriptor (
                 {
                     /* Found a valid ResourceSource */
 
-                    Descriptor->Address32.ResourceLength = (UINT16)
-                        (Descriptor->Address32.ResourceLength + StringLength);
+                    ResourceLength = (UINT16) (ResourceLength + StringLength);
 
                     strcpy ((char *)
                         &OptionalFields[OptionIndex],
@@ -272,13 +271,20 @@ RsDoDwordIoDescriptor (
     /* Validate the Min/Max/Len/Gran values */
 
     RsLargeAddressCheck (
-        (UINT64) Descriptor->Address32.Minimum,
-        (UINT64) Descriptor->Address32.Maximum,
-        (UINT64) Descriptor->Address32.AddressLength,
-        (UINT64) Descriptor->Address32.Granularity,
+        Minimum,
+        Maximum,
+        AddressLength,
+        Granularity,
         Descriptor->Address32.Flags,
         MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
 
+    ACPI_MOVE_16_TO_16(&Descriptor->Address32.ResourceLength, &ResourceLength);
+    ACPI_MOVE_32_TO_32(&Descriptor->Address32.Minimum, &Minimum);
+    ACPI_MOVE_32_TO_32(&Descriptor->Address32.Maximum, &Maximum);
+    ACPI_MOVE_32_TO_32(&Descriptor->Address32.AddressLength, &AddressLength);
+    ACPI_MOVE_32_TO_32(&Descriptor->Address32.Granularity, &Granularity);
+    ACPI_MOVE_32_TO_32(&Descriptor->Address32.TranslationOffset, &TranslationOffset);
+
     Rnode->BufferLength = sizeof (AML_RESOURCE_ADDRESS32) +
         OptionIndex + StringLength;
     return (Rnode);
@@ -310,7 +316,13 @@ RsDoDwordMemoryDescriptor (
     ASL_RESOURCE_NODE       *Rnode;
     UINT8                   *OptionalFields;
     UINT16                  StringLength = 0;
+    UINT16                  ResourceLength = 0;
     UINT32                  OptionIndex = 0;
+    UINT32                  Minimum = 0;
+    UINT32                  Maximum = 0;
+    UINT32                  AddressLength = 0;
+    UINT32                  Granularity = 0;
+    UINT32                  TranslationOffset = 0;
     UINT32                  CurrentByteOffset;
     UINT32                  i;
     BOOLEAN                 ResSourceIndex = FALSE;
@@ -332,11 +344,9 @@ RsDoDwordMemoryDescriptor (
      * optional fields present
      */
     OptionalFields = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_ADDRESS32);
-    Descriptor->Address32.ResourceLength = (UINT16)
-        (sizeof (AML_RESOURCE_ADDRESS32) -
+    ResourceLength = (UINT16) (sizeof (AML_RESOURCE_ADDRESS32) -
          sizeof (AML_RESOURCE_LARGE_HEADER));
 
-
     /* Process all child initialization nodes */
 
     for (i = 0; InitializerOp; i++)
@@ -385,8 +395,7 @@ RsDoDwordMemoryDescriptor (
 
         case 6: /* Address Granularity */
 
-            Descriptor->Address32.Granularity =
-                (UINT32) InitializerOp->Asl.Value.Integer;
+            Granularity = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Granularity));
             GranOp = InitializerOp;
@@ -394,8 +403,7 @@ RsDoDwordMemoryDescriptor (
 
         case 7: /* Min Address */
 
-            Descriptor->Address32.Minimum =
-                (UINT32) InitializerOp->Asl.Value.Integer;
+            Minimum = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_MINADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Minimum));
             MinOp = InitializerOp;
@@ -403,8 +411,7 @@ RsDoDwordMemoryDescriptor (
 
         case 8: /* Max Address */
 
-            Descriptor->Address32.Maximum =
-                (UINT32) InitializerOp->Asl.Value.Integer;
+            Maximum = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_MAXADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Maximum));
             MaxOp = InitializerOp;
@@ -412,16 +419,14 @@ RsDoDwordMemoryDescriptor (
 
         case 9: /* Translation Offset */
 
-            Descriptor->Address32.TranslationOffset =
-                (UINT32) InitializerOp->Asl.Value.Integer;
+            TranslationOffset = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.TranslationOffset));
             break;
 
         case 10: /* Address Length */
 
-            Descriptor->Address32.AddressLength =
-                (UINT32) InitializerOp->Asl.Value.Integer;
+            AddressLength = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_LENGTH,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.AddressLength));
             LengthOp = InitializerOp;
@@ -433,7 +438,7 @@ RsDoDwordMemoryDescriptor (
             {
                 OptionalFields[0] = (UINT8) InitializerOp->Asl.Value.Integer;
                 OptionIndex++;
-                Descriptor->Address32.ResourceLength++;
+                ResourceLength++;
                 ResSourceIndex = TRUE;
             }
             break;
@@ -445,8 +450,8 @@ RsDoDwordMemoryDescriptor (
             {
                 if (StringLength)
                 {
-                    Descriptor->Address32.ResourceLength = (UINT16)
-                        (Descriptor->Address32.ResourceLength + StringLength);
+
+                    ResourceLength = (UINT16) (ResourceLength + StringLength);
 
                     strcpy ((char *)
                         &OptionalFields[OptionIndex],
@@ -507,13 +512,20 @@ RsDoDwordMemoryDescriptor (
     /* Validate the Min/Max/Len/Gran values */
 
     RsLargeAddressCheck (
-        (UINT64) Descriptor->Address32.Minimum,
-        (UINT64) Descriptor->Address32.Maximum,
-        (UINT64) Descriptor->Address32.AddressLength,
-        (UINT64) Descriptor->Address32.Granularity,
+        Minimum,
+        Maximum,
+        AddressLength,
+        Granularity,
         Descriptor->Address32.Flags,
         MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
 
+    ACPI_MOVE_16_TO_16(&Descriptor->Address32.ResourceLength, &ResourceLength);
+    ACPI_MOVE_32_TO_32(&Descriptor->Address32.Minimum, &Minimum);
+    ACPI_MOVE_32_TO_32(&Descriptor->Address32.Maximum, &Maximum);
+    ACPI_MOVE_32_TO_32(&Descriptor->Address32.AddressLength, &AddressLength);
+    ACPI_MOVE_32_TO_32(&Descriptor->Address32.Granularity, &Granularity);
+    ACPI_MOVE_32_TO_32(&Descriptor->Address32.TranslationOffset, &TranslationOffset);
+
     Rnode->BufferLength = sizeof (AML_RESOURCE_ADDRESS32) +
         OptionIndex + StringLength;
     return (Rnode);
@@ -545,7 +557,13 @@ RsDoDwordSpaceDescriptor (
     ASL_RESOURCE_NODE       *Rnode;
     UINT8                   *OptionalFields;
     UINT16                  StringLength = 0;
+    UINT16                  ResourceLength = 0;
     UINT32                  OptionIndex = 0;
+    UINT32                  Minimum = 0;
+    UINT32                  Maximum = 0;
+    UINT32                  AddressLength = 0;
+    UINT32                  Granularity = 0;
+    UINT32                  TranslationOffset = 0;
     UINT32                  CurrentByteOffset;
     UINT32                  i;
     BOOLEAN                 ResSourceIndex = FALSE;
@@ -566,8 +584,7 @@ RsDoDwordSpaceDescriptor (
      * optional fields present
      */
     OptionalFields = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_ADDRESS32);
-    Descriptor->Address32.ResourceLength = (UINT16)
-        (sizeof (AML_RESOURCE_ADDRESS32) -
+    ResourceLength = (UINT16) (sizeof (AML_RESOURCE_ADDRESS32) -
          sizeof (AML_RESOURCE_LARGE_HEADER));
 
     /* Process all child initialization nodes */
@@ -616,8 +633,7 @@ RsDoDwordSpaceDescriptor (
 
         case 6: /* Address Granularity */
 
-            Descriptor->Address32.Granularity =
-                (UINT32) InitializerOp->Asl.Value.Integer;
+            Granularity = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Granularity));
             GranOp = InitializerOp;
@@ -625,8 +641,7 @@ RsDoDwordSpaceDescriptor (
 
         case 7: /* Min Address */
 
-            Descriptor->Address32.Minimum =
-                (UINT32) InitializerOp->Asl.Value.Integer;
+            Minimum = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_MINADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Minimum));
             MinOp = InitializerOp;
@@ -634,8 +649,7 @@ RsDoDwordSpaceDescriptor (
 
         case 8: /* Max Address */
 
-            Descriptor->Address32.Maximum =
-                (UINT32) InitializerOp->Asl.Value.Integer;
+            Maximum = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_MAXADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.Maximum));
             MaxOp = InitializerOp;
@@ -643,16 +657,14 @@ RsDoDwordSpaceDescriptor (
 
         case 9: /* Translation Offset */
 
-            Descriptor->Address32.TranslationOffset =
-                (UINT32) InitializerOp->Asl.Value.Integer;
+            TranslationOffset = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.TranslationOffset));
             break;
 
         case 10: /* Address Length */
 
-            Descriptor->Address32.AddressLength =
-                (UINT32) InitializerOp->Asl.Value.Integer;
+            AddressLength = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_LENGTH,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address32.AddressLength));
             LengthOp = InitializerOp;
@@ -664,7 +676,7 @@ RsDoDwordSpaceDescriptor (
             {
                 OptionalFields[0] = (UINT8) InitializerOp->Asl.Value.Integer;
                 OptionIndex++;
-                Descriptor->Address32.ResourceLength++;
+                ResourceLength++;
                 ResSourceIndex = TRUE;
             }
             break;
@@ -676,8 +688,7 @@ RsDoDwordSpaceDescriptor (
             {
                 if (StringLength)
                 {
-                    Descriptor->Address32.ResourceLength = (UINT16)
-                        (Descriptor->Address32.ResourceLength + StringLength);
+                    ResourceLength = (UINT16) (ResourceLength + StringLength);
 
                     strcpy ((char *)
                         &OptionalFields[OptionIndex],
@@ -724,13 +735,20 @@ RsDoDwordSpaceDescriptor (
     /* Validate the Min/Max/Len/Gran values */
 
     RsLargeAddressCheck (
-        (UINT64) Descriptor->Address32.Minimum,
-        (UINT64) Descriptor->Address32.Maximum,
-        (UINT64) Descriptor->Address32.AddressLength,
-        (UINT64) Descriptor->Address32.Granularity,
+        Minimum,
+        Maximum,
+        AddressLength,
+        Granularity,
         Descriptor->Address32.Flags,
         MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
 
+    ACPI_MOVE_16_TO_16(&Descriptor->Address32.ResourceLength, &ResourceLength);
+    ACPI_MOVE_32_TO_32(&Descriptor->Address32.Minimum, &Minimum);
+    ACPI_MOVE_32_TO_32(&Descriptor->Address32.Maximum, &Maximum);
+    ACPI_MOVE_32_TO_32(&Descriptor->Address32.AddressLength, &AddressLength);
+    ACPI_MOVE_32_TO_32(&Descriptor->Address32.Granularity, &Granularity);
+    ACPI_MOVE_32_TO_32(&Descriptor->Address32.TranslationOffset, &TranslationOffset);
+
     Rnode->BufferLength = sizeof (AML_RESOURCE_ADDRESS32) +
         OptionIndex + StringLength;
     return (Rnode);
Index: acpica-unix-20191213/source/compiler/aslrestype2e.c
===================================================================
--- acpica-unix-20191213.orig/source/compiler/aslrestype2e.c
+++ acpica-unix-20191213/source/compiler/aslrestype2e.c
@@ -78,6 +78,13 @@ RsDoExtendedIoDescriptor (
     ACPI_PARSE_OBJECT       *GranOp = NULL;
     ASL_RESOURCE_NODE       *Rnode;
     UINT16                  StringLength = 0;
+    UINT16                  ResourceLength = 0;
+    UINT64                  Minimum = 0;
+    UINT64                  Maximum = 0;
+    UINT64                  AddressLength = 0;
+    UINT64                  Granularity = 0;
+    UINT64                  TranslationOffset = 0;
+    UINT64                  TypeSpecific = 0;
     UINT32                  CurrentByteOffset;
     UINT32                  i;
 
@@ -94,9 +101,10 @@ RsDoExtendedIoDescriptor (
     Descriptor->ExtAddress64.ResourceType = ACPI_ADDRESS_TYPE_IO_RANGE;
     Descriptor->ExtAddress64.RevisionID = AML_RESOURCE_EXTENDED_ADDRESS_REVISION;
 
-    Descriptor->ExtAddress64.ResourceLength = (UINT16)
-        (sizeof (AML_RESOURCE_EXTENDED_ADDRESS64) -
+    ResourceLength  = (UINT16) (sizeof (AML_RESOURCE_EXTENDED_ADDRESS64) -
          sizeof (AML_RESOURCE_LARGE_HEADER));
+    ACPI_MOVE_16_TO_16(&Descriptor->ExtAddress64.ResourceLength,
+        &ResourceLength);
 
     /* Process all child initialization nodes */
 
@@ -139,7 +147,7 @@ RsDoExtendedIoDescriptor (
 
         case 5: /* Address Granularity */
 
-            Descriptor->ExtAddress64.Granularity = InitializerOp->Asl.Value.Integer;
+            Granularity = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Granularity));
             GranOp = InitializerOp;
@@ -147,7 +155,7 @@ RsDoExtendedIoDescriptor (
 
         case 6: /* Address Min */
 
-            Descriptor->ExtAddress64.Minimum = InitializerOp->Asl.Value.Integer;
+            Minimum = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_MINADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Minimum));
             MinOp = InitializerOp;
@@ -155,7 +163,7 @@ RsDoExtendedIoDescriptor (
 
         case 7: /* Address Max */
 
-            Descriptor->ExtAddress64.Maximum = InitializerOp->Asl.Value.Integer;
+            Maximum = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_MAXADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.Maximum));
             MaxOp = InitializerOp;
@@ -163,14 +171,14 @@ RsDoExtendedIoDescriptor (
 
         case 8: /* Translation Offset */
 
-            Descriptor->ExtAddress64.TranslationOffset = InitializerOp->Asl.Value.Integer;
+            TranslationOffset = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.TranslationOffset));
             break;
 
         case 9: /* Address Length */
 
-            Descriptor->ExtAddress64.AddressLength = InitializerOp->Asl.Value.Integer;
+            AddressLength = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_LENGTH,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.AddressLength));
             LengthOp = InitializerOp;
@@ -178,7 +186,7 @@ RsDoExtendedIoDescriptor (
 
         case 10: /* Type-Specific Attributes */
 
-            Descriptor->ExtAddress64.TypeSpecific = InitializerOp->Asl.Value.Integer;
+            TypeSpecific = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_TYPESPECIFICATTRIBUTES,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (ExtAddress64.TypeSpecific));
             break;
@@ -214,13 +222,20 @@ RsDoExtendedIoDescriptor (
     /* Validate the Min/Max/Len/Gran values */
 
     RsLargeAddressCheck (
-        Descriptor->ExtAddress64.Minimum,
-        Descriptor->ExtAddress64.Maximum,
-        Descriptor->ExtAddress64.AddressLength,
-        Descriptor->ExtAddress64.Granularity,
+        Minimum,
+        Maximum,
+        AddressLength,
+        Granularity,
         Descriptor->ExtAddress64.Flags,
         MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
 
+    ACPI_MOVE_64_TO_64(&Descriptor->ExtAddress64.Minimum, &Minimum);
+    ACPI_MOVE_64_TO_64(&Descriptor->ExtAddress64.Maximum, &Maximum);
+    ACPI_MOVE_64_TO_64(&Descriptor->ExtAddress64.AddressLength, &AddressLength);
+    ACPI_MOVE_64_TO_64(&Descriptor->ExtAddress64.Granularity, &Granularity);
+    ACPI_MOVE_64_TO_64(&Descriptor->ExtAddress64.TranslationOffset, &TranslationOffset);
+    ACPI_MOVE_64_TO_64(&Descriptor->ExtAddress64.TypeSpecific, &TypeSpecific);
+
     Rnode->BufferLength = sizeof (AML_RESOURCE_EXTENDED_ADDRESS64) +
         StringLength;
     return (Rnode);
Index: acpica-unix-20191213/source/compiler/aslrestype2q.c
===================================================================
--- acpica-unix-20191213.orig/source/compiler/aslrestype2q.c
+++ acpica-unix-20191213/source/compiler/aslrestype2q.c
@@ -80,7 +80,13 @@ RsDoQwordIoDescriptor (
     ASL_RESOURCE_NODE       *Rnode;
     UINT8                   *OptionalFields;
     UINT16                  StringLength = 0;
+    UINT16                  ResourceLength = 0;
     UINT32                  OptionIndex = 0;
+    UINT64                  Minimum = 0;
+    UINT64                  Maximum = 0;
+    UINT64                  AddressLength = 0;
+    UINT64                  Granularity = 0;
+    UINT64                  TranslationOffset = 0;
     UINT32                  CurrentByteOffset;
     UINT32                  i;
     BOOLEAN                 ResSourceIndex = FALSE;
@@ -102,8 +108,7 @@ RsDoQwordIoDescriptor (
      * optional fields present
      */
     OptionalFields = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_ADDRESS64);
-    Descriptor->Address64.ResourceLength = (UINT16)
-        (sizeof (AML_RESOURCE_ADDRESS64) -
+    ResourceLength = (UINT16) (sizeof (AML_RESOURCE_ADDRESS64) -
          sizeof (AML_RESOURCE_LARGE_HEADER));
 
     /* Process all child initialization nodes */
@@ -147,7 +152,7 @@ RsDoQwordIoDescriptor (
 
         case 5: /* Address Granularity */
 
-            Descriptor->Address64.Granularity = InitializerOp->Asl.Value.Integer;
+            Granularity = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Granularity));
             GranOp = InitializerOp;
@@ -155,7 +160,7 @@ RsDoQwordIoDescriptor (
 
         case 6: /* Address Min */
 
-            Descriptor->Address64.Minimum = InitializerOp->Asl.Value.Integer;
+            Minimum = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_MINADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Minimum));
             MinOp = InitializerOp;
@@ -163,7 +168,7 @@ RsDoQwordIoDescriptor (
 
         case 7: /* Address Max */
 
-            Descriptor->Address64.Maximum = InitializerOp->Asl.Value.Integer;
+            Maximum = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_MAXADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Maximum));
             MaxOp = InitializerOp;
@@ -171,14 +176,14 @@ RsDoQwordIoDescriptor (
 
         case 8: /* Translation Offset */
 
-            Descriptor->Address64.TranslationOffset = InitializerOp->Asl.Value.Integer;
+            TranslationOffset = InitializerOp->Asl.Value.Integer;
             RsCreateByteField (InitializerOp, ACPI_RESTAG_TRANSLATION,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.TranslationOffset));
             break;
 
         case 9: /* Address Length */
 
-            Descriptor->Address64.AddressLength = InitializerOp->Asl.Value.Integer;
+            AddressLength = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_LENGTH,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.AddressLength));
             LengthOp = InitializerOp;
@@ -190,7 +195,7 @@ RsDoQwordIoDescriptor (
             {
                 OptionalFields[0] = (UINT8) InitializerOp->Asl.Value.Integer;
                 OptionIndex++;
-                Descriptor->Address64.ResourceLength++;
+                ResourceLength++;
                 ResSourceIndex = TRUE;
             }
             break;
@@ -202,8 +207,7 @@ RsDoQwordIoDescriptor (
             {
                 if (StringLength)
                 {
-                    Descriptor->Address64.ResourceLength = (UINT16)
-                        (Descriptor->Address64.ResourceLength + StringLength);
+                    ResourceLength = (UINT16) (ResourceLength + StringLength);
 
                     strcpy ((char *)
                         &OptionalFields[OptionIndex],
@@ -263,13 +267,20 @@ RsDoQwordIoDescriptor (
     /* Validate the Min/Max/Len/Gran values */
 
     RsLargeAddressCheck (
-        Descriptor->Address64.Minimum,
-        Descriptor->Address64.Maximum,
-        Descriptor->Address64.AddressLength,
-        Descriptor->Address64.Granularity,
+        Minimum,
+        Maximum,
+        AddressLength,
+        Granularity,
         Descriptor->Address64.Flags,
         MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
 
+    ACPI_MOVE_16_TO_16(&Descriptor->Address64.ResourceLength, &ResourceLength);
+    ACPI_MOVE_64_TO_64(&Descriptor->Address64.Minimum, &Minimum);
+    ACPI_MOVE_64_TO_64(&Descriptor->Address64.Maximum, &Maximum);
+    ACPI_MOVE_64_TO_64(&Descriptor->Address64.AddressLength, &AddressLength);
+    ACPI_MOVE_64_TO_64(&Descriptor->Address64.Granularity, &Granularity);
+    ACPI_MOVE_64_TO_64(&Descriptor->Address64.TranslationOffset, &TranslationOffset);
+
     Rnode->BufferLength = sizeof (AML_RESOURCE_ADDRESS64) +
         OptionIndex + StringLength;
     return (Rnode);
@@ -301,7 +312,13 @@ RsDoQwordMemoryDescriptor (
     ASL_RESOURCE_NODE       *Rnode;
     UINT8                   *OptionalFields;
     UINT16                  StringLength = 0;
+    UINT16                  ResourceLength = 0;
     UINT32                  OptionIndex = 0;
+    UINT64                  Minimum = 0;
+    UINT64                  Maximum = 0;
+    UINT64                  AddressLength = 0;
+    UINT64                  Granularity = 0;
+    UINT64                  TranslationOffset = 0;
     UINT32                  CurrentByteOffset;
     UINT32                  i;
     BOOLEAN                 ResSourceIndex = FALSE;
@@ -323,8 +340,7 @@ RsDoQwordMemoryDescriptor (
      * optional fields present
      */
     OptionalFields = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_ADDRESS64);
-    Descriptor->Address64.ResourceLength = (UINT16)
-        (sizeof (AML_RESOURCE_ADDRESS64) -
+    ResourceLength = (UINT16) (sizeof (AML_RESOURCE_ADDRESS64) -
          sizeof (AML_RESOURCE_LARGE_HEADER));
 
     /* Process all child initialization nodes */
@@ -375,7 +391,7 @@ RsDoQwordMemoryDescriptor (
 
         case 6: /* Address Granularity */
 
-            Descriptor->Address64.Granularity = InitializerOp->Asl.Value.Integer;
+            Granularity = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Granularity));
             GranOp = InitializerOp;
@@ -383,7 +399,7 @@ RsDoQwordMemoryDescriptor (
 
         case 7: /* Min Address */
 
-            Descriptor->Address64.Minimum = InitializerOp->Asl.Value.Integer;
+            Minimum = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_MINADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Minimum));
             MinOp = InitializerOp;
@@ -391,7 +407,7 @@ RsDoQwordMemoryDescriptor (
 
         case 8: /* Max Address */
 
-            Descriptor->Address64.Maximum = InitializerOp->Asl.Value.Integer;
+            Maximum = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_MAXADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Maximum));
             MaxOp = InitializerOp;
@@ -399,14 +415,14 @@ RsDoQwordMemoryDescriptor (
 
         case 9: /* Translation Offset */
 
-            Descriptor->Address64.TranslationOffset = InitializerOp->Asl.Value.Integer;
+            TranslationOffset = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.TranslationOffset));
             break;
 
         case 10: /* Address Length */
 
-            Descriptor->Address64.AddressLength = InitializerOp->Asl.Value.Integer;
+            AddressLength = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_LENGTH,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.AddressLength));
             LengthOp = InitializerOp;
@@ -418,7 +434,7 @@ RsDoQwordMemoryDescriptor (
             {
                 OptionalFields[0] = (UINT8) InitializerOp->Asl.Value.Integer;
                 OptionIndex++;
-                Descriptor->Address64.ResourceLength++;
+                ResourceLength++;
                 ResSourceIndex = TRUE;
             }
             break;
@@ -430,8 +446,7 @@ RsDoQwordMemoryDescriptor (
             {
                 if (StringLength)
                 {
-                    Descriptor->Address64.ResourceLength = (UINT16)
-                        (Descriptor->Address64.ResourceLength + StringLength);
+                    ResourceLength = (UINT16) (ResourceLength + StringLength);
 
                     strcpy ((char *)
                         &OptionalFields[OptionIndex],
@@ -492,13 +507,20 @@ RsDoQwordMemoryDescriptor (
     /* Validate the Min/Max/Len/Gran values */
 
     RsLargeAddressCheck (
-        Descriptor->Address64.Minimum,
-        Descriptor->Address64.Maximum,
-        Descriptor->Address64.AddressLength,
-        Descriptor->Address64.Granularity,
+        Minimum,
+        Maximum,
+        AddressLength,
+        Granularity,
         Descriptor->Address64.Flags,
         MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
 
+    ACPI_MOVE_16_TO_16(&Descriptor->Address64.ResourceLength, &ResourceLength);
+    ACPI_MOVE_64_TO_64(&Descriptor->Address64.Minimum, &Minimum);
+    ACPI_MOVE_64_TO_64(&Descriptor->Address64.Maximum, &Maximum);
+    ACPI_MOVE_64_TO_64(&Descriptor->Address64.AddressLength, &AddressLength);
+    ACPI_MOVE_64_TO_64(&Descriptor->Address64.Granularity, &Granularity);
+    ACPI_MOVE_64_TO_64(&Descriptor->Address64.TranslationOffset, &TranslationOffset);
+
     Rnode->BufferLength = sizeof (AML_RESOURCE_ADDRESS64) +
         OptionIndex + StringLength;
     return (Rnode);
@@ -530,9 +552,15 @@ RsDoQwordSpaceDescriptor (
     ASL_RESOURCE_NODE       *Rnode;
     UINT8                   *OptionalFields;
     UINT16                  StringLength = 0;
+    UINT16                  ResourceLength = 0;
     UINT32                  OptionIndex = 0;
     UINT32                  CurrentByteOffset;
     UINT32                  i;
+    UINT64                  Minimum = 0;
+    UINT64                  Maximum = 0;
+    UINT64                  AddressLength = 0;
+    UINT64                  Granularity = 0;
+    UINT64                  TranslationOffset = 0;
     BOOLEAN                 ResSourceIndex = FALSE;
 
 
@@ -551,8 +579,7 @@ RsDoQwordSpaceDescriptor (
      * optional fields present
      */
     OptionalFields = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_ADDRESS64);
-    Descriptor->Address64.ResourceLength = (UINT16)
-        (sizeof (AML_RESOURCE_ADDRESS64) -
+    ResourceLength = (UINT16) (sizeof (AML_RESOURCE_ADDRESS64) -
          sizeof (AML_RESOURCE_LARGE_HEADER));
 
     /* Process all child initialization nodes */
@@ -601,7 +628,7 @@ RsDoQwordSpaceDescriptor (
 
         case 6: /* Address Granularity */
 
-            Descriptor->Address64.Granularity = InitializerOp->Asl.Value.Integer;
+            Granularity = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Granularity));
             GranOp = InitializerOp;
@@ -609,7 +636,7 @@ RsDoQwordSpaceDescriptor (
 
         case 7: /* Min Address */
 
-            Descriptor->Address64.Minimum = InitializerOp->Asl.Value.Integer;
+            Minimum = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_MINADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Minimum));
             MinOp = InitializerOp;
@@ -617,7 +644,7 @@ RsDoQwordSpaceDescriptor (
 
         case 8: /* Max Address */
 
-            Descriptor->Address64.Maximum = InitializerOp->Asl.Value.Integer;
+            Maximum = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_MAXADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.Maximum));
             MaxOp = InitializerOp;
@@ -625,14 +652,14 @@ RsDoQwordSpaceDescriptor (
 
         case 9: /* Translation Offset */
 
-            Descriptor->Address64.TranslationOffset = InitializerOp->Asl.Value.Integer;
+            TranslationOffset = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.TranslationOffset));
             break;
 
         case 10: /* Address Length */
 
-            Descriptor->Address64.AddressLength = InitializerOp->Asl.Value.Integer;
+            AddressLength = InitializerOp->Asl.Value.Integer;
             RsCreateQwordField (InitializerOp, ACPI_RESTAG_LENGTH,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address64.AddressLength));
             LengthOp = InitializerOp;
@@ -644,7 +671,7 @@ RsDoQwordSpaceDescriptor (
             {
                 OptionalFields[0] = (UINT8) InitializerOp->Asl.Value.Integer;
                 OptionIndex++;
-                Descriptor->Address64.ResourceLength++;
+                ResourceLength++;
                 ResSourceIndex = TRUE;
             }
             break;
@@ -656,8 +683,7 @@ RsDoQwordSpaceDescriptor (
             {
                 if (StringLength)
                 {
-                    Descriptor->Address64.ResourceLength = (UINT16)
-                        (Descriptor->Address64.ResourceLength + StringLength);
+                    ResourceLength = (UINT16) (ResourceLength + StringLength);
 
                     strcpy ((char *)
                         &OptionalFields[OptionIndex],
@@ -703,13 +729,20 @@ RsDoQwordSpaceDescriptor (
     /* Validate the Min/Max/Len/Gran values */
 
     RsLargeAddressCheck (
-        Descriptor->Address64.Minimum,
-        Descriptor->Address64.Maximum,
-        Descriptor->Address64.AddressLength,
-        Descriptor->Address64.Granularity,
+        Minimum,
+        Maximum,
+        AddressLength,
+        Granularity,
         Descriptor->Address64.Flags,
         MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
 
+    ACPI_MOVE_16_TO_16(&Descriptor->Address64.ResourceLength, &ResourceLength);
+    ACPI_MOVE_64_TO_64(&Descriptor->Address64.Minimum, &Minimum);
+    ACPI_MOVE_64_TO_64(&Descriptor->Address64.Maximum, &Maximum);
+    ACPI_MOVE_64_TO_64(&Descriptor->Address64.AddressLength, &AddressLength);
+    ACPI_MOVE_64_TO_64(&Descriptor->Address64.Granularity, &Granularity);
+    ACPI_MOVE_64_TO_64(&Descriptor->Address64.TranslationOffset, &TranslationOffset);
+
     Rnode->BufferLength = sizeof (AML_RESOURCE_ADDRESS64) +
         OptionIndex + StringLength;
     return (Rnode);
Index: acpica-unix-20191213/source/compiler/aslrestype2s.c
===================================================================
--- acpica-unix-20191213.orig/source/compiler/aslrestype2s.c
+++ acpica-unix-20191213/source/compiler/aslrestype2s.c
@@ -340,9 +340,14 @@ RsDoGpioIntDescriptor (
     UINT16                  VendorLength;
     UINT16                  InterruptLength;
     UINT16                  DescriptorSize;
+    UINT16                  IntFlags = 0;
+    UINT16                  DebounceTimeout = 0;
+    UINT16                  Flags = 0;
     UINT32                  CurrentByteOffset;
     UINT32                  PinCount = 0;
     UINT32                  i;
+    UINT16		    Tmp16;
+    UINT16		    Val16;
 
 
     InitializerOp = Info->DescriptorTypeOp->Asl.Child;
@@ -367,7 +372,7 @@ RsDoGpioIntDescriptor (
         sizeof (AML_RESOURCE_LARGE_HEADER));
 
     Descriptor = Rnode->Buffer;
-    Descriptor->Gpio.ResourceLength = DescriptorSize;
+    ACPI_MOVE_16_TO_16(&Descriptor->Gpio.ResourceLength, &DescriptorSize);
     Descriptor->Gpio.DescriptorType = ACPI_RESOURCE_NAME_GPIO;
     Descriptor->Gpio.RevisionId = AML_RESOURCE_GPIO_REVISION;
     Descriptor->Gpio.ConnectionType = AML_RESOURCE_GPIO_TYPE_INT;
@@ -382,11 +387,11 @@ RsDoGpioIntDescriptor (
 
     /* Setup offsets within the descriptor */
 
-    Descriptor->Gpio.PinTableOffset = (UINT16)
-        ACPI_PTR_DIFF (InterruptList, Descriptor);
+    Tmp16 = (UINT16) ACPI_PTR_DIFF (InterruptList, Descriptor);
+    ACPI_MOVE_16_TO_16(&Descriptor->Gpio.PinTableOffset, &Tmp16);
 
-    Descriptor->Gpio.ResSourceOffset = (UINT16)
-        ACPI_PTR_DIFF (ResourceSource, Descriptor);
+    Tmp16 = (UINT16) ACPI_PTR_DIFF (ResourceSource, Descriptor);
+    ACPI_MOVE_16_TO_16(&Descriptor->Gpio.ResSourceOffset, &Tmp16);
 
     /* Process all child initialization nodes */
 
@@ -396,21 +401,21 @@ RsDoGpioIntDescriptor (
         {
         case 0: /* Interrupt Mode - edge/level [Flag] (_MOD) */
 
-            RsSetFlagBits16 (&Descriptor->Gpio.IntFlags, InitializerOp, 0, 0);
+            RsSetFlagBits16 (&IntFlags, InitializerOp, 0, 0);
             RsCreateBitField (InitializerOp, ACPI_RESTAG_MODE,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Gpio.IntFlags), 0);
             break;
 
         case 1: /* Interrupt Polarity - Active high/low [Flags] (_POL) */
 
-            RsSetFlagBits16 (&Descriptor->Gpio.IntFlags, InitializerOp, 1, 0);
+            RsSetFlagBits16 (&IntFlags, InitializerOp, 1, 0);
             RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_POLARITY,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Gpio.IntFlags), 1, 2);
             break;
 
         case 2: /* Share Type - Default: exclusive (0) [Flags] (_SHR) */
 
-            RsSetFlagBits16 (&Descriptor->Gpio.IntFlags, InitializerOp, 3, 0);
+            RsSetFlagBits16 (&IntFlags, InitializerOp, 3, 0);
             RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_INTERRUPTSHARE,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Gpio.IntFlags), 3, 2);
             break;
@@ -424,7 +429,7 @@ RsDoGpioIntDescriptor (
 
         case 4: /* Debounce Timeout [WORD] (_DBT) */
 
-            Descriptor->Gpio.DebounceTimeout = (UINT16) InitializerOp->Asl.Value.Integer;
+            DebounceTimeout = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_DEBOUNCETIME,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Gpio.DebounceTimeout));
             break;
@@ -451,7 +456,7 @@ RsDoGpioIntDescriptor (
 
         case 7: /* Resource Usage (consumer/producer) */
 
-            RsSetFlagBits16 (&Descriptor->Gpio.Flags, InitializerOp, 0, 1);
+            RsSetFlagBits16 (&Flags, InitializerOp, 0, 1);
             break;
 
         case 8: /* Resource Tag (Descriptor Name) */
@@ -466,13 +471,14 @@ RsDoGpioIntDescriptor (
              * This field is required in order to calculate the length
              * of the ResourceSource at runtime.
              */
-            Descriptor->Gpio.VendorOffset = (UINT16)
-                ACPI_PTR_DIFF (VendorData, Descriptor);
+            Tmp16 = (UINT16) ACPI_PTR_DIFF (VendorData, Descriptor);
+            ACPI_MOVE_16_TO_16(&Descriptor->Gpio.VendorOffset, &Tmp16);
 
             if (RsGetVendorData (InitializerOp, VendorData,
-                (CurrentByteOffset +  Descriptor->Gpio.VendorOffset)))
+                (CurrentByteOffset + Tmp16)))
             {
-                Descriptor->Gpio.VendorLength = VendorLength;
+                ACPI_MOVE_16_TO_16(&Descriptor->Gpio.VendorLength,
+				   &VendorLength);
             }
             break;
 
@@ -485,7 +491,9 @@ RsDoGpioIntDescriptor (
              *  (implies resource source must immediately follow the pin list.)
              *  Name: _PIN
              */
-            *InterruptList = (UINT16) InitializerOp->Asl.Value.Integer;
+            Tmp16 = (UINT16) InitializerOp->Asl.Value.Integer;
+            ACPI_MOVE_16_TO_16(&Val16, &Tmp16);
+            *InterruptList = Val16;
             InterruptList++;
             PinCount++;
 
@@ -507,8 +515,10 @@ RsDoGpioIntDescriptor (
 
                 /* Create a named field at the start of the list */
 
-                RsCreateWordField (InitializerOp, ACPI_RESTAG_PIN,
-                    CurrentByteOffset + Descriptor->Gpio.PinTableOffset);
+		ACPI_MOVE_16_TO_16(&Tmp16, &Descriptor->Gpio.PinTableOffset);
+		Tmp16 += CurrentByteOffset;
+	        ACPI_MOVE_16_TO_16(&Val16, &Tmp16);
+                RsCreateWordField (InitializerOp, ACPI_RESTAG_PIN, Val16);
             }
             break;
         }
@@ -516,6 +526,10 @@ RsDoGpioIntDescriptor (
         InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
     }
 
+    ACPI_MOVE_16_TO_16(&Descriptor->Gpio.IntFlags, &IntFlags);
+    ACPI_MOVE_16_TO_16(&Descriptor->Gpio.DebounceTimeout, &DebounceTimeout);
+    ACPI_MOVE_16_TO_16(&Descriptor->Gpio.Flags, &Flags);
+
     MpSaveGpioInfo (Info->MappingOp, Descriptor,
         PinCount, PinList, ResourceSource);
     return (Rnode);
@@ -549,9 +563,15 @@ RsDoGpioIoDescriptor (
     UINT16                  VendorLength;
     UINT16                  InterruptLength;
     UINT16                  DescriptorSize;
+    UINT16                  IntFlags = 0;
+    UINT16                  DebounceTimeout = 0;
+    UINT16                  DriveStrength = 0;
+    UINT16                  Flags = 0;
     UINT32                  CurrentByteOffset;
     UINT32                  PinCount = 0;
     UINT32                  i;
+    UINT16		    Tmp16;
+    UINT16		    Val16;
 
 
     InitializerOp = Info->DescriptorTypeOp->Asl.Child;
@@ -576,7 +596,7 @@ RsDoGpioIoDescriptor (
         sizeof (AML_RESOURCE_LARGE_HEADER));
 
     Descriptor = Rnode->Buffer;
-    Descriptor->Gpio.ResourceLength = DescriptorSize;
+    ACPI_MOVE_16_TO_16(&Descriptor->Gpio.ResourceLength, &DescriptorSize);
     Descriptor->Gpio.DescriptorType = ACPI_RESOURCE_NAME_GPIO;
     Descriptor->Gpio.RevisionId = AML_RESOURCE_GPIO_REVISION;
     Descriptor->Gpio.ConnectionType = AML_RESOURCE_GPIO_TYPE_IO;
@@ -590,11 +610,11 @@ RsDoGpioIoDescriptor (
 
     /* Setup offsets within the descriptor */
 
-    Descriptor->Gpio.PinTableOffset = (UINT16)
-        ACPI_PTR_DIFF (InterruptList, Descriptor);
+    Tmp16 = (UINT16) ACPI_PTR_DIFF (InterruptList, Descriptor);
+    ACPI_MOVE_16_TO_16(&Descriptor->Gpio.PinTableOffset, &Tmp16);
 
-    Descriptor->Gpio.ResSourceOffset = (UINT16)
-        ACPI_PTR_DIFF (ResourceSource, Descriptor);
+    Tmp16 = (UINT16) ACPI_PTR_DIFF (ResourceSource, Descriptor);
+    ACPI_MOVE_16_TO_16(&Descriptor->Gpio.ResSourceOffset, &Tmp16);
 
     /* Process all child initialization nodes */
 
@@ -604,7 +624,7 @@ RsDoGpioIoDescriptor (
         {
         case 0: /* Share Type [Flags] (_SHR) */
 
-            RsSetFlagBits16 (&Descriptor->Gpio.IntFlags, InitializerOp, 3, 0);
+            RsSetFlagBits16 (&IntFlags, InitializerOp, 3, 0);
             RsCreateBitField (InitializerOp, ACPI_RESTAG_INTERRUPTSHARE,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Gpio.IntFlags), 3);
             break;
@@ -618,21 +638,21 @@ RsDoGpioIoDescriptor (
 
         case 2: /* Debounce Timeout [WORD] (_DBT) */
 
-            Descriptor->Gpio.DebounceTimeout = (UINT16) InitializerOp->Asl.Value.Integer;
+            DebounceTimeout = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_DEBOUNCETIME,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Gpio.DebounceTimeout));
             break;
 
         case 3: /* Drive Strength [WORD] (_DRS) */
 
-            Descriptor->Gpio.DriveStrength = (UINT16) InitializerOp->Asl.Value.Integer;
+            DriveStrength = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_DRIVESTRENGTH,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Gpio.DriveStrength));
             break;
 
         case 4: /* I/O Restriction [Flag] (_IOR) */
 
-            RsSetFlagBits16 (&Descriptor->Gpio.IntFlags, InitializerOp, 0, 0);
+            RsSetFlagBits16 (&IntFlags, InitializerOp, 0, 0);
             RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_IORESTRICTION,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Gpio.IntFlags), 0, 2);
             break;
@@ -658,7 +678,7 @@ RsDoGpioIoDescriptor (
 
         case 7: /* Resource Usage (consumer/producer) */
 
-            RsSetFlagBits16 (&Descriptor->Gpio.Flags, InitializerOp, 0, 1);
+            RsSetFlagBits16 (&Flags, InitializerOp, 0, 1);
             break;
 
         case 8: /* Resource Tag (Descriptor Name) */
@@ -672,13 +692,14 @@ RsDoGpioIoDescriptor (
              * This field is required in order to calculate the length
              * of the ResourceSource at runtime.
              */
-            Descriptor->Gpio.VendorOffset = (UINT16)
-                ACPI_PTR_DIFF (VendorData, Descriptor);
+            Tmp16 = (UINT16) ACPI_PTR_DIFF (VendorData, Descriptor);
+            ACPI_MOVE_16_TO_16(&Descriptor->Gpio.VendorOffset, &Tmp16);
 
             if (RsGetVendorData (InitializerOp, VendorData,
                 (CurrentByteOffset + Descriptor->Gpio.VendorOffset)))
             {
-                Descriptor->Gpio.VendorLength = VendorLength;
+                ACPI_MOVE_16_TO_16(&Descriptor->Gpio.VendorLength,
+				   &VendorLength);
             }
             break;
 
@@ -691,7 +712,9 @@ RsDoGpioIoDescriptor (
              *  (implies resource source must immediately follow the pin list.)
              *  Name: _PIN
              */
-            *InterruptList = (UINT16) InitializerOp->Asl.Value.Integer;
+            Tmp16 = (UINT16) InitializerOp->Asl.Value.Integer;
+	    ACPI_MOVE_16_TO_16(&Val16, &Tmp16);
+            *InterruptList = Val16;
             InterruptList++;
             PinCount++;
 
@@ -722,6 +745,11 @@ RsDoGpioIoDescriptor (
         InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
     }
 
+    ACPI_MOVE_16_TO_16(&Descriptor->Gpio.IntFlags, &IntFlags);
+    ACPI_MOVE_16_TO_16(&Descriptor->Gpio.DebounceTimeout, &DebounceTimeout);
+    ACPI_MOVE_16_TO_16(&Descriptor->Gpio.DriveStrength, &DriveStrength);
+    ACPI_MOVE_16_TO_16(&Descriptor->Gpio.Flags, &Flags);
+
     MpSaveGpioInfo (Info->MappingOp, Descriptor,
         PinCount, PinList, ResourceSource);
     return (Rnode);
@@ -752,8 +780,12 @@ RsDoI2cSerialBusDescriptor (
     UINT16                  ResSourceLength;
     UINT16                  VendorLength;
     UINT16                  DescriptorSize;
+    UINT16                  SlaveAddress = 0;
+    UINT32                  ConnectionSpeed = 0;
+    UINT16                  TypeSpecificFlags = 0;
     UINT32                  CurrentByteOffset;
     UINT32                  i;
+    UINT16		    Tmp16;
 
 
     InitializerOp = Info->DescriptorTypeOp->Asl.Child;
@@ -776,12 +808,14 @@ RsDoI2cSerialBusDescriptor (
         sizeof (AML_RESOURCE_LARGE_HEADER));
 
     Descriptor = Rnode->Buffer;
-    Descriptor->I2cSerialBus.ResourceLength = DescriptorSize;
+    ACPI_MOVE_16_TO_16(&Descriptor->I2cSerialBus.ResourceLength,
+		       &DescriptorSize);
     Descriptor->I2cSerialBus.DescriptorType = ACPI_RESOURCE_NAME_SERIAL_BUS;
     Descriptor->I2cSerialBus.RevisionId = AML_RESOURCE_I2C_REVISION;
     Descriptor->I2cSerialBus.TypeRevisionId = AML_RESOURCE_I2C_TYPE_REVISION;
     Descriptor->I2cSerialBus.Type = AML_RESOURCE_I2C_SERIALBUSTYPE;
-    Descriptor->I2cSerialBus.TypeDataLength = AML_RESOURCE_I2C_MIN_DATA_LEN + VendorLength;
+    Tmp16 = AML_RESOURCE_I2C_MIN_DATA_LEN + VendorLength;
+    ACPI_MOVE_16_TO_16(&Descriptor->I2cSerialBus.TypeDataLength, &Tmp16);
 
     if (Info->DescriptorTypeOp->Asl.ParseOpcode == PARSEOP_I2C_SERIALBUS_V2)
     {
@@ -801,7 +835,7 @@ RsDoI2cSerialBusDescriptor (
         {
         case 0: /* Slave Address [WORD] (_ADR) */
 
-            Descriptor->I2cSerialBus.SlaveAddress = (UINT16) InitializerOp->Asl.Value.Integer;
+            SlaveAddress = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_ADDRESS,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (I2cSerialBus.SlaveAddress));
             break;
@@ -815,14 +849,14 @@ RsDoI2cSerialBusDescriptor (
 
         case 2: /* Connection Speed [DWORD] (_SPE) */
 
-            Descriptor->I2cSerialBus.ConnectionSpeed = (UINT32) InitializerOp->Asl.Value.Integer;
+            ConnectionSpeed = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_SPEED,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (I2cSerialBus.ConnectionSpeed));
             break;
 
         case 3: /* Addressing Mode [Flag] (_MOD) */
 
-            RsSetFlagBits16 (&Descriptor->I2cSerialBus.TypeSpecificFlags, InitializerOp, 0, 0);
+            RsSetFlagBits16 (&TypeSpecificFlags, InitializerOp, 0, 0);
             RsCreateBitField (InitializerOp, ACPI_RESTAG_MODE,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (I2cSerialBus.TypeSpecificFlags), 0);
             break;
@@ -882,6 +916,9 @@ RsDoI2cSerialBusDescriptor (
         InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
     }
 
+    ACPI_MOVE_16_TO_16(&Descriptor->I2cSerialBus.SlaveAddress, &SlaveAddress);
+    ACPI_MOVE_32_TO_32(&Descriptor->I2cSerialBus.ConnectionSpeed, &ConnectionSpeed);
+    ACPI_MOVE_16_TO_16(&Descriptor->I2cSerialBus.TypeSpecificFlags, &TypeSpecificFlags);
     MpSaveSerialInfo (Info->MappingOp, Descriptor, ResourceSource);
     return (Rnode);
 }
@@ -911,6 +948,9 @@ RsDoSpiSerialBusDescriptor (
     UINT16                  ResSourceLength;
     UINT16                  VendorLength;
     UINT16                  DescriptorSize;
+    UINT16                  DeviceSelection = 0;
+    UINT32                  ConnectionSpeed = 0;
+    UINT16                  TypeSpecificFlags = 0;
     UINT32                  CurrentByteOffset;
     UINT32                  i;
 
@@ -961,21 +1001,21 @@ RsDoSpiSerialBusDescriptor (
         {
         case 0: /* Device Selection [WORD] (_ADR) */
 
-            Descriptor->SpiSerialBus.DeviceSelection = (UINT16) InitializerOp->Asl.Value.Integer;
+            DeviceSelection = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_ADDRESS,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (SpiSerialBus.DeviceSelection));
             break;
 
         case 1: /* Device Polarity [Flag] (_DPL) */
 
-            RsSetFlagBits16 (&Descriptor->SpiSerialBus.TypeSpecificFlags, InitializerOp, 1, 0);
+            RsSetFlagBits16 (&TypeSpecificFlags, InitializerOp, 1, 0);
             RsCreateBitField (InitializerOp, ACPI_RESTAG_DEVICEPOLARITY,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (SpiSerialBus.TypeSpecificFlags), 1);
             break;
 
         case 2: /* Wire Mode [Flag] (_MOD) */
 
-            RsSetFlagBits16 (&Descriptor->SpiSerialBus.TypeSpecificFlags, InitializerOp, 0, 0);
+            RsSetFlagBits16 (&TypeSpecificFlags, InitializerOp, 0, 0);
             RsCreateBitField (InitializerOp, ACPI_RESTAG_MODE,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (SpiSerialBus.TypeSpecificFlags), 0);
             break;
@@ -996,7 +1036,7 @@ RsDoSpiSerialBusDescriptor (
 
         case 5: /* Connection Speed [DWORD] (_SPE) */
 
-            Descriptor->SpiSerialBus.ConnectionSpeed = (UINT32) InitializerOp->Asl.Value.Integer;
+            ConnectionSpeed = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_SPEED,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (SpiSerialBus.ConnectionSpeed));
             break;
@@ -1070,6 +1110,10 @@ RsDoSpiSerialBusDescriptor (
         InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
     }
 
+    ACPI_MOVE_16_TO_16(&Descriptor->SpiSerialBus.DeviceSelection, &DeviceSelection);
+    ACPI_MOVE_32_TO_32(&Descriptor->SpiSerialBus.ConnectionSpeed, &ConnectionSpeed);
+    ACPI_MOVE_16_TO_16(&Descriptor->SpiSerialBus.TypeSpecificFlags, &TypeSpecificFlags);
+
     MpSaveSerialInfo (Info->MappingOp, Descriptor, ResourceSource);
     return (Rnode);
 }
@@ -1099,6 +1143,10 @@ RsDoUartSerialBusDescriptor (
     UINT16                  ResSourceLength;
     UINT16                  VendorLength;
     UINT16                  DescriptorSize;
+    UINT32                  DefaultBaudRate = 0;
+    UINT16                  TypeSpecificFlags = 0;
+    UINT16                  RxFifoSize = 0;
+    UINT16                  TxFifoSize = 0;
     UINT32                  CurrentByteOffset;
     UINT32                  i;
 
@@ -1148,21 +1196,21 @@ RsDoUartSerialBusDescriptor (
         {
         case 0: /* Connection Speed (Baud Rate) [DWORD] (_SPE) */
 
-            Descriptor->UartSerialBus.DefaultBaudRate = (UINT32) InitializerOp->Asl.Value.Integer;
+            DefaultBaudRate = (UINT32) InitializerOp->Asl.Value.Integer;
             RsCreateDwordField (InitializerOp, ACPI_RESTAG_SPEED,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (UartSerialBus.DefaultBaudRate));
             break;
 
         case 1: /* Bits Per Byte [Flags] (_LEN) */
 
-            RsSetFlagBits16 (&Descriptor->UartSerialBus.TypeSpecificFlags, InitializerOp, 4, 3);
+            RsSetFlagBits16 (&TypeSpecificFlags, InitializerOp, 4, 3);
             RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_LENGTH,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (UartSerialBus.TypeSpecificFlags), 4, 3);
             break;
 
         case 2: /* Stop Bits [Flags] (_STB) */
 
-            RsSetFlagBits16 (&Descriptor->UartSerialBus.TypeSpecificFlags, InitializerOp, 2, 1);
+            RsSetFlagBits16 (&TypeSpecificFlags, InitializerOp, 2, 1);
             RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_STOPBITS,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (UartSerialBus.TypeSpecificFlags), 2, 2);
             break;
@@ -1176,7 +1224,7 @@ RsDoUartSerialBusDescriptor (
 
         case 4: /* Endianness [Flag] (_END) */
 
-            RsSetFlagBits16 (&Descriptor->UartSerialBus.TypeSpecificFlags, InitializerOp, 7, 0);
+            RsSetFlagBits16 (&TypeSpecificFlags, InitializerOp, 7, 0);
             RsCreateBitField (InitializerOp, ACPI_RESTAG_ENDIANNESS,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (UartSerialBus.TypeSpecificFlags), 7);
             break;
@@ -1190,21 +1238,21 @@ RsDoUartSerialBusDescriptor (
 
         case 6: /* Flow Control [Flags] (_FLC) */
 
-            RsSetFlagBits16 (&Descriptor->UartSerialBus.TypeSpecificFlags, InitializerOp, 0, 0);
+            RsSetFlagBits16 (&TypeSpecificFlags, InitializerOp, 0, 0);
             RsCreateMultiBitField (InitializerOp, ACPI_RESTAG_FLOWCONTROL,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (UartSerialBus.TypeSpecificFlags), 0, 2);
             break;
 
         case 7: /* Rx Buffer Size [WORD] (_RXL) */
 
-            Descriptor->UartSerialBus.RxFifoSize = (UINT16) InitializerOp->Asl.Value.Integer;
+            RxFifoSize = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_LENGTH_RX,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (UartSerialBus.RxFifoSize));
             break;
 
         case 8: /* Tx Buffer Size [WORD] (_TXL) */
 
-            Descriptor->UartSerialBus.TxFifoSize = (UINT16) InitializerOp->Asl.Value.Integer;
+            TxFifoSize = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_LENGTH_TX,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (UartSerialBus.TxFifoSize));
             break;
@@ -1274,6 +1322,11 @@ RsDoUartSerialBusDescriptor (
         InitializerOp = RsCompleteNodeAndGetNext (InitializerOp);
     }
 
+    ACPI_MOVE_32_TO_32(&Descriptor->UartSerialBus.DefaultBaudRate, &DefaultBaudRate);
+    ACPI_MOVE_16_TO_16(&Descriptor->UartSerialBus.TypeSpecificFlags, &TypeSpecificFlags);
+    ACPI_MOVE_16_TO_16(&Descriptor->UartSerialBus.RxFifoSize, &RxFifoSize);
+    ACPI_MOVE_16_TO_16(&Descriptor->UartSerialBus.TxFifoSize, &TxFifoSize);
+
     MpSaveSerialInfo (Info->MappingOp, Descriptor, ResourceSource);
     return (Rnode);
 }
Index: acpica-unix-20191213/source/compiler/aslrestype2w.c
===================================================================
--- acpica-unix-20191213.orig/source/compiler/aslrestype2w.c
+++ acpica-unix-20191213/source/compiler/aslrestype2w.c
@@ -81,6 +81,12 @@ RsDoWordIoDescriptor (
     UINT8                   *OptionalFields;
     UINT16                  StringLength = 0;
     UINT32                  OptionIndex = 0;
+    UINT16                  ResourceLength = 0;
+    UINT16                  Minimum = 0;
+    UINT16                  Maximum = 0;
+    UINT16                  AddressLength = 0;
+    UINT16                  Granularity = 0;
+    UINT16                  TranslationOffset = 0;
     UINT32                  CurrentByteOffset;
     UINT32                  i;
     BOOLEAN                 ResSourceIndex = FALSE;
@@ -102,8 +108,7 @@ RsDoWordIoDescriptor (
      * optional fields present
      */
     OptionalFields = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_ADDRESS16);
-    Descriptor->Address16.ResourceLength = (UINT16)
-        (sizeof (AML_RESOURCE_ADDRESS16) -
+    ResourceLength = (UINT16) (sizeof (AML_RESOURCE_ADDRESS16) -
          sizeof (AML_RESOURCE_LARGE_HEADER));
 
     /* Process all child initialization nodes */
@@ -147,7 +152,7 @@ RsDoWordIoDescriptor (
 
         case 5: /* Address Granularity */
 
-            Descriptor->Address16.Granularity = (UINT16) InitializerOp->Asl.Value.Integer;
+            Granularity = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Granularity));
             GranOp = InitializerOp;
@@ -155,7 +160,7 @@ RsDoWordIoDescriptor (
 
         case 6: /* Address Min */
 
-            Descriptor->Address16.Minimum = (UINT16) InitializerOp->Asl.Value.Integer;
+            Minimum = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_MINADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Minimum));
             MinOp = InitializerOp;
@@ -163,7 +168,7 @@ RsDoWordIoDescriptor (
 
         case 7: /* Address Max */
 
-            Descriptor->Address16.Maximum = (UINT16) InitializerOp->Asl.Value.Integer;
+            Maximum = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_MAXADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Maximum));
             MaxOp = InitializerOp;
@@ -171,14 +176,14 @@ RsDoWordIoDescriptor (
 
         case 8: /* Translation Offset */
 
-            Descriptor->Address16.TranslationOffset = (UINT16) InitializerOp->Asl.Value.Integer;
+            TranslationOffset = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.TranslationOffset));
             break;
 
         case 9: /* Address Length */
 
-            Descriptor->Address16.AddressLength = (UINT16) InitializerOp->Asl.Value.Integer;
+            AddressLength = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_LENGTH,
                  CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.AddressLength));
             LengthOp = InitializerOp;
@@ -190,7 +195,7 @@ RsDoWordIoDescriptor (
             {
                 OptionalFields[0] = (UINT8) InitializerOp->Asl.Value.Integer;
                 OptionIndex++;
-                Descriptor->Address16.ResourceLength++;
+                ResourceLength++;
                 ResSourceIndex = TRUE;
             }
             break;
@@ -202,8 +207,7 @@ RsDoWordIoDescriptor (
             {
                 if (StringLength)
                 {
-                    Descriptor->Address16.ResourceLength = (UINT16)
-                        (Descriptor->Address16.ResourceLength + StringLength);
+                    ResourceLength = (UINT16) (ResourceLength + StringLength);
 
                     strcpy ((char *)
                         &OptionalFields[OptionIndex],
@@ -263,13 +267,20 @@ RsDoWordIoDescriptor (
     /* Validate the Min/Max/Len/Gran values */
 
     RsLargeAddressCheck (
-        (UINT64) Descriptor->Address16.Minimum,
-        (UINT64) Descriptor->Address16.Maximum,
-        (UINT64) Descriptor->Address16.AddressLength,
-        (UINT64) Descriptor->Address16.Granularity,
+        Minimum,
+        Maximum,
+        AddressLength,
+        Granularity,
         Descriptor->Address16.Flags,
         MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
 
+    ACPI_MOVE_16_TO_16(&Descriptor->Address16.ResourceLength, &ResourceLength);
+    ACPI_MOVE_16_TO_16(&Descriptor->Address16.Minimum, &Minimum);
+    ACPI_MOVE_16_TO_16(&Descriptor->Address16.Maximum, &Maximum);
+    ACPI_MOVE_16_TO_16(&Descriptor->Address16.AddressLength, &AddressLength);
+    ACPI_MOVE_16_TO_16(&Descriptor->Address16.Granularity, &Granularity);
+    ACPI_MOVE_16_TO_16(&Descriptor->Address16.TranslationOffset, &TranslationOffset);
+
     Rnode->BufferLength = sizeof (AML_RESOURCE_ADDRESS16) +
         OptionIndex + StringLength;
     return (Rnode);
@@ -302,6 +313,12 @@ RsDoWordBusNumberDescriptor (
     UINT8                   *OptionalFields;
     UINT16                  StringLength = 0;
     UINT32                  OptionIndex = 0;
+    UINT16                  ResourceLength = 0;
+    UINT16                  Minimum = 0;
+    UINT16                  Maximum = 0;
+    UINT16                  AddressLength = 0;
+    UINT16                  Granularity = 0;
+    UINT16                  TranslationOffset = 0;
     UINT32                  CurrentByteOffset;
     UINT32                  i;
     BOOLEAN                 ResSourceIndex = FALSE;
@@ -323,8 +340,7 @@ RsDoWordBusNumberDescriptor (
      * optional fields present
      */
     OptionalFields = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_ADDRESS16);
-    Descriptor->Address16.ResourceLength = (UINT16)
-        (sizeof (AML_RESOURCE_ADDRESS16) -
+    ResourceLength = (UINT16) (sizeof (AML_RESOURCE_ADDRESS16) -
          sizeof (AML_RESOURCE_LARGE_HEADER));
 
     /* Process all child initialization nodes */
@@ -361,8 +377,7 @@ RsDoWordBusNumberDescriptor (
 
         case 4: /* Address Granularity */
 
-            Descriptor->Address16.Granularity =
-                (UINT16) InitializerOp->Asl.Value.Integer;
+            Granularity = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Granularity));
             GranOp = InitializerOp;
@@ -370,8 +385,7 @@ RsDoWordBusNumberDescriptor (
 
         case 5: /* Min Address */
 
-            Descriptor->Address16.Minimum =
-                (UINT16) InitializerOp->Asl.Value.Integer;
+            Minimum = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_MINADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Minimum));
             MinOp = InitializerOp;
@@ -379,8 +393,7 @@ RsDoWordBusNumberDescriptor (
 
         case 6: /* Max Address */
 
-            Descriptor->Address16.Maximum =
-                (UINT16) InitializerOp->Asl.Value.Integer;
+            Maximum = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_MAXADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Maximum));
             MaxOp = InitializerOp;
@@ -388,16 +401,14 @@ RsDoWordBusNumberDescriptor (
 
         case 7: /* Translation Offset */
 
-            Descriptor->Address16.TranslationOffset =
-                (UINT16) InitializerOp->Asl.Value.Integer;
+            TranslationOffset = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.TranslationOffset));
             break;
 
         case 8: /* Address Length */
 
-            Descriptor->Address16.AddressLength =
-                (UINT16) InitializerOp->Asl.Value.Integer;
+            AddressLength = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_LENGTH,
                  CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.AddressLength));
             LengthOp = InitializerOp;
@@ -409,7 +420,7 @@ RsDoWordBusNumberDescriptor (
             {
                 OptionalFields[0] = (UINT8) InitializerOp->Asl.Value.Integer;
                 OptionIndex++;
-                Descriptor->Address16.ResourceLength++;
+                ResourceLength++;
                 ResSourceIndex = TRUE;
             }
             break;
@@ -421,8 +432,7 @@ RsDoWordBusNumberDescriptor (
             {
                 if (StringLength)
                 {
-                    Descriptor->Address16.ResourceLength = (UINT16)
-                        (Descriptor->Address16.ResourceLength + StringLength);
+                    ResourceLength = (UINT16) (ResourceLength + StringLength);
 
                     strcpy ((char *)
                         &OptionalFields[OptionIndex],
@@ -468,13 +478,20 @@ RsDoWordBusNumberDescriptor (
     /* Validate the Min/Max/Len/Gran values */
 
     RsLargeAddressCheck (
-        (UINT64) Descriptor->Address16.Minimum,
-        (UINT64) Descriptor->Address16.Maximum,
-        (UINT64) Descriptor->Address16.AddressLength,
-        (UINT64) Descriptor->Address16.Granularity,
+        Minimum,
+        Maximum,
+        AddressLength,
+        Granularity,
         Descriptor->Address16.Flags,
         MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
 
+    ACPI_MOVE_16_TO_16(&Descriptor->Address16.ResourceLength, &ResourceLength);
+    ACPI_MOVE_16_TO_16(&Descriptor->Address16.Minimum, &Minimum);
+    ACPI_MOVE_16_TO_16(&Descriptor->Address16.Maximum, &Maximum);
+    ACPI_MOVE_16_TO_16(&Descriptor->Address16.AddressLength, &AddressLength);
+    ACPI_MOVE_16_TO_16(&Descriptor->Address16.Granularity, &Granularity);
+    ACPI_MOVE_16_TO_16(&Descriptor->Address16.TranslationOffset, &TranslationOffset);
+
     Rnode->BufferLength = sizeof (AML_RESOURCE_ADDRESS16) +
         OptionIndex + StringLength;
     return (Rnode);
@@ -507,6 +524,12 @@ RsDoWordSpaceDescriptor (
     UINT8                   *OptionalFields;
     UINT16                  StringLength = 0;
     UINT32                  OptionIndex = 0;
+    UINT16                  Minimum = 0;
+    UINT16                  Maximum = 0;
+    UINT16                  AddressLength = 0;
+    UINT16                  Granularity = 0;
+    UINT16                  TranslationOffset = 0;
+    UINT16                  ResourceLength = 0;
     UINT32                  CurrentByteOffset;
     UINT32                  i;
     BOOLEAN                 ResSourceIndex = FALSE;
@@ -527,8 +550,7 @@ RsDoWordSpaceDescriptor (
      * optional fields present
      */
     OptionalFields = ((UINT8 *) Descriptor) + sizeof (AML_RESOURCE_ADDRESS16);
-    Descriptor->Address16.ResourceLength = (UINT16)
-        (sizeof (AML_RESOURCE_ADDRESS16) -
+    ResourceLength = (UINT16) (sizeof (AML_RESOURCE_ADDRESS16) -
          sizeof (AML_RESOURCE_LARGE_HEADER));
 
     /* Process all child initialization nodes */
@@ -577,8 +599,7 @@ RsDoWordSpaceDescriptor (
 
         case 6: /* Address Granularity */
 
-            Descriptor->Address16.Granularity =
-                (UINT16) InitializerOp->Asl.Value.Integer;
+            Granularity = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_GRANULARITY,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Granularity));
             GranOp = InitializerOp;
@@ -586,8 +607,7 @@ RsDoWordSpaceDescriptor (
 
         case 7: /* Min Address */
 
-            Descriptor->Address16.Minimum =
-                (UINT16) InitializerOp->Asl.Value.Integer;
+            Minimum = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_MINADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Minimum));
             MinOp = InitializerOp;
@@ -595,8 +615,7 @@ RsDoWordSpaceDescriptor (
 
         case 8: /* Max Address */
 
-            Descriptor->Address16.Maximum =
-                (UINT16) InitializerOp->Asl.Value.Integer;
+            Maximum = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_MAXADDR,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.Maximum));
             MaxOp = InitializerOp;
@@ -604,16 +623,14 @@ RsDoWordSpaceDescriptor (
 
         case 9: /* Translation Offset */
 
-            Descriptor->Address16.TranslationOffset =
-                (UINT16) InitializerOp->Asl.Value.Integer;
+            TranslationOffset = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_TRANSLATION,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.TranslationOffset));
             break;
 
         case 10: /* Address Length */
 
-            Descriptor->Address16.AddressLength =
-                (UINT16) InitializerOp->Asl.Value.Integer;
+            AddressLength = (UINT16) InitializerOp->Asl.Value.Integer;
             RsCreateWordField (InitializerOp, ACPI_RESTAG_LENGTH,
                 CurrentByteOffset + ASL_RESDESC_OFFSET (Address16.AddressLength));
             LengthOp = InitializerOp;
@@ -625,7 +642,7 @@ RsDoWordSpaceDescriptor (
             {
                 OptionalFields[0] = (UINT8) InitializerOp->Asl.Value.Integer;
                 OptionIndex++;
-                Descriptor->Address16.ResourceLength++;
+                ResourceLength++;
                 ResSourceIndex = TRUE;
             }
             break;
@@ -637,8 +654,7 @@ RsDoWordSpaceDescriptor (
             {
                 if (StringLength)
                 {
-                    Descriptor->Address16.ResourceLength = (UINT16)
-                        (Descriptor->Address16.ResourceLength + StringLength);
+                    ResourceLength = (UINT16) (ResourceLength + StringLength);
 
                     strcpy ((char *)
                         &OptionalFields[OptionIndex],
@@ -684,13 +700,20 @@ RsDoWordSpaceDescriptor (
     /* Validate the Min/Max/Len/Gran values */
 
     RsLargeAddressCheck (
-        (UINT64) Descriptor->Address16.Minimum,
-        (UINT64) Descriptor->Address16.Maximum,
-        (UINT64) Descriptor->Address16.AddressLength,
-        (UINT64) Descriptor->Address16.Granularity,
+        Minimum,
+        Maximum,
+        AddressLength,
+        Granularity,
         Descriptor->Address16.Flags,
         MinOp, MaxOp, LengthOp, GranOp, Info->DescriptorTypeOp);
 
+    ACPI_MOVE_16_TO_16(&Descriptor->Address16.ResourceLength, &ResourceLength);
+    ACPI_MOVE_16_TO_16(&Descriptor->Address16.Minimum, &Minimum);
+    ACPI_MOVE_16_TO_16(&Descriptor->Address16.Maximum, &Maximum);
+    ACPI_MOVE_16_TO_16(&Descriptor->Address16.AddressLength, &AddressLength);
+    ACPI_MOVE_16_TO_16(&Descriptor->Address16.Granularity, &Granularity);
+    ACPI_MOVE_16_TO_16(&Descriptor->Address16.TranslationOffset, &TranslationOffset);
+
     Rnode->BufferLength = sizeof (AML_RESOURCE_ADDRESS16) +
         OptionIndex + StringLength;
     return (Rnode);
Index: acpica-unix-20191213/source/include/acmacros.h
===================================================================
--- acpica-unix-20191213.orig/source/include/acmacros.h
+++ acpica-unix-20191213/source/include/acmacros.h
@@ -98,9 +98,12 @@
                                            ((UINT8 *)(void *)(d))[6] = ((UINT8 *)(void *)(s))[1];\
                                            ((UINT8 *)(void *)(d))[7] = ((UINT8 *)(void *)(s))[0];}
 
-/* 32-bit source, 16/32/64 destination */
+/* 32-bit source, 8/16/32/64 destination */
 
-#define ACPI_MOVE_32_TO_16(d, s)        ACPI_MOVE_16_TO_16(d, s)    /* Truncate to 16 */
+#define ACPI_MOVE_32_TO_8(d, s)        {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[3];}
+
+#define ACPI_MOVE_32_TO_16(d, s)        {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[3];\
+                                         ((  UINT8 *)(void *)(d))[1] = ((UINT8 *)(void *)(s))[2];}
 
 #define ACPI_MOVE_32_TO_32(d, s)        {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[3];\
                                          ((  UINT8 *)(void *)(d))[1] = ((UINT8 *)(void *)(s))[2];\
@@ -113,11 +116,17 @@
                                            ((UINT8 *)(void *)(d))[6] = ((UINT8 *)(void *)(s))[1];\
                                            ((UINT8 *)(void *)(d))[7] = ((UINT8 *)(void *)(s))[0];}
 
-/* 64-bit source, 16/32/64 destination */
+/* 64-bit source, 8/16/32/64 destination */
 
-#define ACPI_MOVE_64_TO_16(d, s)        ACPI_MOVE_16_TO_16(d, s)    /* Truncate to 16 */
+#define ACPI_MOVE_64_TO_8(d, s)        {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[7];}
 
-#define ACPI_MOVE_64_TO_32(d, s)        ACPI_MOVE_32_TO_32(d, s)    /* Truncate to 32 */
+#define ACPI_MOVE_64_TO_16(d, s)        {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[7];\
+                                         ((  UINT8 *)(void *)(d))[1] = ((UINT8 *)(void *)(s))[6];}
+
+#define ACPI_MOVE_64_TO_32(d, s)        {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[7];\
+                                         ((  UINT8 *)(void *)(d))[1] = ((UINT8 *)(void *)(s))[6];\
+                                         ((  UINT8 *)(void *)(d))[2] = ((UINT8 *)(void *)(s))[5];\
+                                         ((  UINT8 *)(void *)(d))[3] = ((UINT8 *)(void *)(s))[4];}
 
 #define ACPI_MOVE_64_TO_64(d, s)        {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[7];\
                                          ((  UINT8 *)(void *)(d))[1] = ((UINT8 *)(void *)(s))[6];\
@@ -136,20 +145,26 @@
 
 /* The hardware supports unaligned transfers, just do the little-endian move */
 
-/* 16-bit source, 16/32/64 destination */
+/* 16-bit source, 8/16/32/64 destination */
 
+#define ACPI_MOVE_16_TO_8(d, s)         *(UINT8 *)(void *)(d) = *(UINT16 *)(void *)(s)
 #define ACPI_MOVE_16_TO_16(d, s)        *(UINT16 *)(void *)(d) = *(UINT16 *)(void *)(s)
 #define ACPI_MOVE_16_TO_32(d, s)        *(UINT32 *)(void *)(d) = *(UINT16 *)(void *)(s)
 #define ACPI_MOVE_16_TO_64(d, s)        *(UINT64 *)(void *)(d) = *(UINT16 *)(void *)(s)
 
-/* 32-bit source, 16/32/64 destination */
+/* 32-bit source, 8/16/32/64 destination */
+
+#define ACPI_MOVE_32_TO_8(d, s)        {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[0];}
+
+#define ACPI_MOVE_32_TO_16(d, s)        {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[0];\
+                                         ((  UINT8 *)(void *)(d))[1] = ((UINT8 *)(void *)(s))[1];}
 
-#define ACPI_MOVE_32_TO_16(d, s)        ACPI_MOVE_16_TO_16(d, s)    /* Truncate to 16 */
 #define ACPI_MOVE_32_TO_32(d, s)        *(UINT32 *)(void *)(d) = *(UINT32 *)(void *)(s)
 #define ACPI_MOVE_32_TO_64(d, s)        *(UINT64 *)(void *)(d) = *(UINT32 *)(void *)(s)
 
-/* 64-bit source, 16/32/64 destination */
+/* 64-bit source, 8/16/32/64 destination */
 
+#define ACPI_MOVE_64_TO_8(d, s)         ACPI_MOVE_16_TO_8(d, s)    /* Truncate to 8 */
 #define ACPI_MOVE_64_TO_16(d, s)        ACPI_MOVE_16_TO_16(d, s)    /* Truncate to 16 */
 #define ACPI_MOVE_64_TO_32(d, s)        ACPI_MOVE_32_TO_32(d, s)    /* Truncate to 32 */
 #define ACPI_MOVE_64_TO_64(d, s)        *(UINT64 *)(void *)(d) = *(UINT64 *)(void *)(s)
@@ -169,7 +184,9 @@
 #define ACPI_MOVE_16_TO_32(d, s)        {(*(UINT32 *)(void *)(d)) = 0; ACPI_MOVE_16_TO_16(d, s);}
 #define ACPI_MOVE_16_TO_64(d, s)        {(*(UINT64 *)(void *)(d)) = 0; ACPI_MOVE_16_TO_16(d, s);}
 
-/* 32-bit source, 16/32/64 destination */
+/* 32-bit source, 8/16/32/64 destination */
+
+#define ACPI_MOVE_32_TO_8(d, s)         ACPI_MOVE_16_TO_8(d, s)    /* Truncate to 8 */
 
 #define ACPI_MOVE_32_TO_16(d, s)        ACPI_MOVE_16_TO_16(d, s)    /* Truncate to 16 */
 
Index: acpica-unix-20191213/source/include/platform/aclinux.h
===================================================================
--- acpica-unix-20191213.orig/source/include/platform/aclinux.h
+++ acpica-unix-20191213/source/include/platform/aclinux.h
@@ -198,6 +198,7 @@
 
 #ifdef ACPI_USE_STANDARD_HEADERS
 #include <unistd.h>
+#include <endian.h>
 #endif
 
 /* Define/disable kernel-specific declarators */
@@ -232,6 +233,10 @@
 #define __cdecl
 #endif
 
+#if defined(__PPC64__) || defined(__s390x__)
+#define ACPI_BIG_ENDIAN
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif /* __ACLINUX_H__ */
Index: acpica-unix-20191213/source/compiler/aslanalyze.c
===================================================================
--- acpica-unix-20191213.orig/source/compiler/aslanalyze.c
+++ acpica-unix-20191213/source/compiler/aslanalyze.c
@@ -461,7 +461,7 @@ ApCheckForGpeNameConflict (
 
     /* Need a null-terminated string version of NameSeg */
 
-    ACPI_MOVE_32_TO_32 (Name, Op->Asl.NameSeg);
+    ACPI_COPY_NAMESEG (Name, Op->Asl.NameSeg);
     Name[ACPI_NAMESEG_SIZE] = 0;
 
     /*
@@ -488,7 +488,7 @@ ApCheckForGpeNameConflict (
      * We are now sure we have an _Lxx or _Exx.
      * Create the target name that would cause collision (Flip E/L)
      */
-    ACPI_MOVE_32_TO_32 (Target, Name);
+    ACPI_COPY_NAMESEG (Target, Name);
 
     /* Inject opposite letter ("L" versus "E") */
 
Index: acpica-unix-20191213/source/compiler/asllookup.c
===================================================================
--- acpica-unix-20191213.orig/source/compiler/asllookup.c
+++ acpica-unix-20191213/source/compiler/asllookup.c
@@ -119,6 +119,7 @@ LkIsObjectUsed (
 {
     ACPI_NAMESPACE_NODE     *Node = ACPI_CAST_PTR (ACPI_NAMESPACE_NODE, ObjHandle);
     ACPI_NAMESPACE_NODE     *Next;
+    ACPI_NAME_UNION         tmp, tmp2;
     ASL_METHOD_LOCAL        *MethodLocals;
     ASL_METHOD_LOCAL        *MethodArgs;
     UINT32                  i;
@@ -175,7 +176,8 @@ LkIsObjectUsed (
                  * We ignore the predefined methods since often, not
                  * all arguments are needed or used.
                  */
-                if ((Node->Name.Ascii[0] != '_') &&
+                ACPI_MOVE_32_TO_32(&tmp.Ascii, Node->Name.Ascii);
+                if ((tmp.Ascii[0] != '_') &&
                     (!(MethodArgs[i].Flags & ASL_ARG_REFERENCED)))
                 {
                     sprintf (AslGbl_MsgBuffer, "Arg%u", i);
@@ -228,8 +230,10 @@ LkIsObjectUsed (
              * Issue a remark even if it is a reserved name (starts
              * with an underscore).
              */
+            ACPI_MOVE_32_TO_32(&tmp.Ascii, Node->Name.Ascii);
+            ACPI_MOVE_32_TO_32(&tmp2.Ascii, Next->Name.Ascii);
             sprintf (AslGbl_MsgBuffer, "Name [%4.4s] is within a method [%4.4s]",
-                Node->Name.Ascii, Next->Name.Ascii);
+                tmp.Ascii, tmp2.Ascii);
             AslError (ASL_REMARK, ASL_MSG_NOT_REFERENCED,
                 LkGetNameOp (Node->Op), AslGbl_MsgBuffer);
             return (AE_OK);
Index: acpica-unix-20191213/source/compiler/aslmain.c
===================================================================
--- acpica-unix-20191213.orig/source/compiler/aslmain.c
+++ acpica-unix-20191213/source/compiler/aslmain.c
@@ -101,18 +101,6 @@ main (
 
     signal (SIGINT, AslSignalHandler);
 
-    /*
-     * Big-endian machines are not currently supported. ACPI tables must
-     * be little-endian, and support for big-endian machines needs to
-     * be implemented.
-     */
-    if (UtIsBigEndianMachine ())
-    {
-        fprintf (stderr,
-            "iASL is not currently supported on big-endian machines.\n");
-        return (-1);
-    }
-
     AcpiOsInitialize ();
     ACPI_DEBUG_INITIALIZE (); /* For debug version only */
 
Index: acpica-unix-20191213/source/common/acfileio.c
===================================================================
--- acpica-unix-20191213.orig/source/common/acfileio.c
+++ acpica-unix-20191213/source/common/acfileio.c
@@ -280,6 +280,7 @@ AcGetOneTableFromFile (
     ACPI_TABLE_HEADER       *Table;
     INT32                   Count;
     long                    TableOffset;
+    UINT32		    TableLen;
 
 
     *ReturnTable = NULL;
@@ -319,7 +320,8 @@ AcGetOneTableFromFile (
 
     /* Allocate a buffer for the entire table */
 
-    Table = AcpiOsAllocate ((ACPI_SIZE) TableHeader.Length);
+    ACPI_MOVE_32_TO_32(&TableLen, &TableHeader.Length);
+    Table = AcpiOsAllocate ((ACPI_SIZE) TableLen);
     if (!Table)
     {
         return (AE_NO_MEMORY);
@@ -329,13 +331,13 @@ AcGetOneTableFromFile (
 
     fseek (File, TableOffset, SEEK_SET);
 
-    Count = fread (Table, 1, TableHeader.Length, File);
+    Count = fread (Table, 1, TableLen, File);
 
     /*
      * Checks for data table headers happen later in the execution. Only verify
      * for Aml tables at this point in the code.
      */
-    if (GetOnlyAmlTables && Count != (INT32) TableHeader.Length)
+    if (GetOnlyAmlTables && Count != TableLen)
     {
         Status = AE_ERROR;
         goto ErrorExit;
@@ -343,7 +345,7 @@ AcGetOneTableFromFile (
 
     /* Validate the checksum (just issue a warning) */
 
-    Status = AcpiTbVerifyChecksum (Table, TableHeader.Length);
+    Status = AcpiTbVerifyChecksum (Table, TableLen);
     if (ACPI_FAILURE (Status))
     {
         Status = AcCheckTextModeCorruption (Table);
@@ -435,6 +437,7 @@ AcValidateTableHeader (
     ACPI_SIZE               Actual;
     long                    OriginalOffset;
     UINT32                  FileSize;
+    UINT32                  TableLength;
     UINT32                  i;
 
 
@@ -464,11 +467,12 @@ AcValidateTableHeader (
     /* Validate table length against bytes remaining in the file */
 
     FileSize = CmGetFileSize (File);
-    if (TableHeader.Length > (UINT32) (FileSize - TableOffset))
+    ACPI_MOVE_32_TO_32(&TableLength, &TableHeader.Length);
+    if (TableLength > (UINT32) (FileSize - TableOffset))
     {
         fprintf (stderr, "Table [%4.4s] is too long for file - "
             "needs: 0x%.2X, remaining in file: 0x%.2X\n",
-            TableHeader.Signature, TableHeader.Length,
+            TableHeader.Signature, TableLength,
             (UINT32) (FileSize - TableOffset));
         return (AE_BAD_HEADER);
     }
Index: acpica-unix-20191213/source/common/dmtable.c
===================================================================
--- acpica-unix-20191213.orig/source/common/dmtable.c
+++ acpica-unix-20191213/source/common/dmtable.c
@@ -551,7 +551,7 @@ AcpiDmDumpDataTable (
      */
     if (ACPI_COMPARE_NAMESEG (Table->Signature, ACPI_SIG_FACS))
     {
-        Length = Table->Length;
+        ACPI_MOVE_32_TO_32(&Length, &Table->Length);
         Status = AcpiDmDumpTable (Length, 0, Table, 0, AcpiDmTableInfoFacs);
         if (ACPI_FAILURE (Status))
         {
@@ -565,13 +565,14 @@ AcpiDmDumpDataTable (
     else if (ACPI_COMPARE_NAMESEG (Table->Signature, ACPI_SIG_S3PT))
     {
         Length = AcpiDmDumpS3pt (Table);
+        ACPI_MOVE_32_TO_32(&Length, &Table->Length);
     }
     else
     {
         /*
          * All other tables must use the common ACPI table header, dump it now
          */
-        Length = Table->Length;
+        ACPI_MOVE_32_TO_32(&Length, &Table->Length);
         Status = AcpiDmDumpTable (Length, 0, Table, 0, AcpiDmTableInfoHeader);
         if (ACPI_FAILURE (Status))
         {
@@ -782,6 +783,7 @@ AcpiDmDumpTable (
     BOOLEAN                 LastOutputBlankLine = FALSE;
     ACPI_STATUS             Status;
     char                    RepairedName[8];
+    UINT16		    Val16;
 
 
     if (!Info)
@@ -1178,8 +1180,9 @@ AcpiDmDumpTable (
             /* Checksum, display and validate */
 
             AcpiOsPrintf ("%2.2X", *Target);
-            Temp8 = AcpiDmGenerateChecksum (Table,
-                ACPI_CAST_PTR (ACPI_TABLE_HEADER, Table)->Length,
+	    ACPI_MOVE_32_TO_32(&Temp32,
+			&ACPI_CAST_PTR (ACPI_TABLE_HEADER, Table)->Length);
+            Temp8 = AcpiDmGenerateChecksum (Table, Temp32,
                 ACPI_CAST_PTR (ACPI_TABLE_HEADER, Table)->Checksum);
 
             if (Temp8 != ACPI_CAST_PTR (ACPI_TABLE_HEADER, Table)->Checksum)
@@ -1244,14 +1247,14 @@ AcpiDmDumpTable (
 
             /* DMAR subtable types */
 
-            Temp16 = ACPI_GET16 (Target);
+            Val16 = ACPI_GET16 (Target);
+	    ACPI_MOVE_16_TO_16(&Temp16, &Val16);
             if (Temp16 > ACPI_DMAR_TYPE_RESERVED)
             {
                 Temp16 = ACPI_DMAR_TYPE_RESERVED;
             }
 
-            AcpiOsPrintf (UINT16_FORMAT, ACPI_GET16 (Target),
-                AcpiDmDmarSubnames[Temp16]);
+            AcpiOsPrintf (UINT16_FORMAT, Temp16, AcpiDmDmarSubnames[Temp16]);
             break;
 
         case ACPI_DMT_DMAR_SCOPE:
@@ -1342,14 +1345,14 @@ AcpiDmDumpTable (
 
             /* HEST subtable types */
 
-            Temp16 = ACPI_GET16 (Target);
+            Val16 = ACPI_GET16 (Target);
+	    ACPI_MOVE_16_TO_16(&Temp16, &Val16);
             if (Temp16 > ACPI_HEST_TYPE_RESERVED)
             {
                 Temp16 = ACPI_HEST_TYPE_RESERVED;
             }
 
-            AcpiOsPrintf (UINT16_FORMAT, ACPI_GET16 (Target),
-                AcpiDmHestSubnames[Temp16]);
+            AcpiOsPrintf (UINT16_FORMAT, Temp16, AcpiDmHestSubnames[Temp16]);
             break;
 
         case ACPI_DMT_HESTNTFY:
@@ -1429,13 +1432,14 @@ AcpiDmDumpTable (
 
             /* NFIT subtable types */
 
-            Temp16 = ACPI_GET16 (Target);
+            Val16 = ACPI_GET16 (Target);
+            ACPI_MOVE_16_TO_16(&Temp16, &Val16);
             if (Temp16 > ACPI_NFIT_TYPE_RESERVED)
             {
                 Temp16 = ACPI_NFIT_TYPE_RESERVED;
             }
 
-            AcpiOsPrintf (UINT16_FORMAT, ACPI_GET16 (Target),
+            AcpiOsPrintf (UINT16_FORMAT, Temp16,
                 AcpiDmNfitSubnames[Temp16]);
             break;
 
Index: acpica-unix-20191213/source/common/dmtables.c
===================================================================
--- acpica-unix-20191213.orig/source/common/dmtables.c
+++ acpica-unix-20191213/source/common/dmtables.c
@@ -142,7 +142,9 @@ AdCreateTableHeader (
     ACPI_TABLE_HEADER       *Table)
 {
     UINT8                   Checksum;
-
+    UINT32		    TableLen;
+    UINT32		    OemRev;
+    UINT32		    CompilerRev;
 
     /* Reset globals for External statements */
 
@@ -154,9 +156,10 @@ AdCreateTableHeader (
      */
     AdDisassemblerHeader (Filename, ACPI_IS_AML_TABLE);
 
+    ACPI_MOVE_32_TO_32(&TableLen, &Table->Length);
     AcpiOsPrintf (" * Original Table Header:\n");
     AcpiOsPrintf (" *     Signature        \"%4.4s\"\n",    Table->Signature);
-    AcpiOsPrintf (" *     Length           0x%8.8X (%u)\n", Table->Length, Table->Length);
+    AcpiOsPrintf (" *     Length           0x%8.8X (%u)\n", TableLen, TableLen);
 
     /* Print and validate the revision */
 
@@ -188,7 +191,7 @@ AdCreateTableHeader (
 
     AcpiOsPrintf ("\n *     Checksum         0x%2.2X",        Table->Checksum);
 
-    Checksum = AcpiTbChecksum (ACPI_CAST_PTR (UINT8, Table), Table->Length);
+    Checksum = AcpiTbChecksum (ACPI_CAST_PTR (UINT8, Table), TableLen);
     if (Checksum)
     {
         AcpiOsPrintf (" **** Incorrect checksum, should be 0x%2.2X",
@@ -198,9 +201,11 @@ AdCreateTableHeader (
     AcpiOsPrintf ("\n");
     AcpiOsPrintf (" *     OEM ID           \"%.6s\"\n",     Table->OemId);
     AcpiOsPrintf (" *     OEM Table ID     \"%.8s\"\n",     Table->OemTableId);
-    AcpiOsPrintf (" *     OEM Revision     0x%8.8X (%u)\n", Table->OemRevision, Table->OemRevision);
+    ACPI_MOVE_32_TO_32(&OemRev, &Table->OemRevision);
+    AcpiOsPrintf (" *     OEM Revision     0x%8.8X (%u)\n", OemRev, OemRev);
     AcpiOsPrintf (" *     Compiler ID      \"%.4s\"\n",     Table->AslCompilerId);
-    AcpiOsPrintf (" *     Compiler Version 0x%8.8X (%u)\n", Table->AslCompilerRevision, Table->AslCompilerRevision);
+    ACPI_MOVE_32_TO_32(&CompilerRev, &Table->AslCompilerRevision);
+    AcpiOsPrintf (" *     Compiler Version 0x%8.8X (%u)\n", CompilerRev, CompilerRev);
     AcpiOsPrintf (" */\n");
 
     /*
@@ -221,7 +226,7 @@ AdCreateTableHeader (
     AcpiOsPrintf (
         "DefinitionBlock (\"\", \"%4.4s\", %u, \"%.6s\", \"%.8s\", 0x%8.8X)\n",
         Table->Signature, Table->Revision,
-        Table->OemId, Table->OemTableId, Table->OemRevision);
+        Table->OemId, Table->OemTableId, OemRev);
 }
 
 
@@ -396,7 +401,8 @@ AdParseTable (
 
     fprintf (stderr, "Pass 1 parse of [%4.4s]\n", (char *) Table->Signature);
 
-    AmlLength = Table->Length - sizeof (ACPI_TABLE_HEADER);
+    ACPI_MOVE_32_TO_32(&AmlLength, &Table->Length);
+    AmlLength -= sizeof (ACPI_TABLE_HEADER);
     AmlStart = ((UINT8 *) Table + sizeof (ACPI_TABLE_HEADER));
     ASL_CV_INIT_FILETREE(Table, AmlStart, AmlLength);
 
Index: acpica-unix-20191213/source/compiler/dtfield.c
===================================================================
--- acpica-unix-20191213.orig/source/compiler/dtfield.c
+++ acpica-unix-20191213/source/compiler/dtfield.c
@@ -361,7 +361,27 @@ DtCompileInteger (
         DtError (ASL_ERROR, ASL_MSG_INTEGER_SIZE, Field, AslGbl_MsgBuffer);
     }
 
-    memcpy (Buffer, &Value, ByteLength);
+    switch (ByteLength) {
+    case 1:
+	ACPI_MOVE_64_TO_8(Buffer, &Value);
+	break;
+
+    case 2:
+	ACPI_MOVE_64_TO_16(Buffer, &Value);
+	break;
+
+    case 4:
+	ACPI_MOVE_64_TO_32(Buffer, &Value);
+	break;
+
+    case 8:
+	ACPI_MOVE_64_TO_64(Buffer, &Value);
+	break;
+
+    default:
+	memcpy (Buffer, &Value, ByteLength);
+	break;
+    }
     return;
 }
 
Index: acpica-unix-20191213/source/compiler/dtsubtable.c
===================================================================
--- acpica-unix-20191213.orig/source/compiler/dtsubtable.c
+++ acpica-unix-20191213/source/compiler/dtsubtable.c
@@ -378,6 +378,21 @@ DtSetSubtableLength (
         return;
     }
 
-    memcpy (Subtable->LengthField, &Subtable->TotalLength,
-        Subtable->SizeOfLengthField);
+    switch(Subtable->SizeOfLengthField) {
+    case 1:
+	ACPI_MOVE_32_TO_8(Subtable->LengthField, &Subtable->TotalLength);
+	break;
+
+    case 2:
+	ACPI_MOVE_32_TO_16(Subtable->LengthField, &Subtable->TotalLength);
+	break;
+
+    case 4:
+	ACPI_MOVE_32_TO_32(Subtable->LengthField, &Subtable->TotalLength);
+	break;
+
+    default:
+    	memcpy (Subtable->LengthField, &Subtable->TotalLength,
+        	Subtable->SizeOfLengthField);
+    }
 }
Index: acpica-unix-20191213/source/compiler/dttable1.c
===================================================================
--- acpica-unix-20191213.orig/source/compiler/dttable1.c
+++ acpica-unix-20191213/source/compiler/dttable1.c
@@ -281,6 +281,8 @@ DtCompileCsrt (
     DT_FIELD                **PFieldList = (DT_FIELD **) List;
     UINT32                  DescriptorCount;
     UINT32                  GroupLength;
+    ACPI_CSRT_GROUP	    *Pgrp;
+    UINT32		    Tmp32;
 
 
     /* Subtables (Resource Groups) */
@@ -299,12 +301,20 @@ DtCompileCsrt (
 
         /* Compute the number of resource descriptors */
 
+	/*
         GroupLength =
             (ACPI_CAST_PTR (ACPI_CSRT_GROUP,
                 Subtable->Buffer))->Length -
             (ACPI_CAST_PTR (ACPI_CSRT_GROUP,
                 Subtable->Buffer))->SharedInfoLength -
             sizeof (ACPI_CSRT_GROUP);
+	*/
+	Pgrp = ACPI_CAST_PTR(ACPI_CSRT_GROUP, Subtable->Buffer);
+	ACPI_MOVE_32_TO_32(&Tmp32, &Pgrp->Length);
+	GroupLength = Tmp32;
+	ACPI_MOVE_32_TO_32(&Tmp32, &Pgrp->SharedInfoLength);
+	GroupLength -= Tmp32;
+        GroupLength -= sizeof (ACPI_CSRT_GROUP);
 
         DescriptorCount = (GroupLength  /
             sizeof (ACPI_CSRT_DESCRIPTOR));
@@ -392,6 +402,8 @@ DtCompileDbg2 (
     ACPI_DBG2_DEVICE        *DeviceInfo;
     UINT16                  CurrentOffset;
     UINT32                  i;
+    UINT16                  Tmp16;
+    UINT32                  Tmp32;
 
 
     /* Main table */
@@ -408,10 +420,11 @@ DtCompileDbg2 (
     /* Main table fields */
 
     Dbg2Header = ACPI_CAST_PTR (ACPI_DBG2_HEADER, Subtable->Buffer);
-    Dbg2Header->InfoOffset = sizeof (ACPI_TABLE_HEADER) + ACPI_PTR_DIFF (
+    Tmp32 = sizeof (ACPI_TABLE_HEADER) + ACPI_PTR_DIFF (
         ACPI_ADD_PTR (UINT8, Dbg2Header, sizeof (ACPI_DBG2_HEADER)), Dbg2Header);
+    ACPI_MOVE_32_TO_32(&Dbg2Header->InfoOffset, &Tmp32);
 
-    SubtableCount = Dbg2Header->InfoCount;
+    ACPI_MOVE_32_TO_32(&SubtableCount, &Dbg2Header->InfoCount);
     DtPushSubtable (Subtable);
 
     /* Process all Device Information subtables (Count = InfoCount) */
@@ -438,7 +451,7 @@ DtCompileDbg2 (
 
         /* BaseAddressRegister GAS array (Required, size is RegisterCount) */
 
-        DeviceInfo->BaseAddressOffset = CurrentOffset;
+        ACPI_MOVE_16_TO_16(&DeviceInfo->BaseAddressOffset, &CurrentOffset);
         for (i = 0; *PFieldList && (i < DeviceInfo->RegisterCount); i++)
         {
             Status = DtCompileTable (PFieldList, AcpiDmTableInfoDbg2Addr,
@@ -454,7 +467,7 @@ DtCompileDbg2 (
 
         /* AddressSize array (Required, size = RegisterCount) */
 
-        DeviceInfo->AddressSizeOffset = CurrentOffset;
+        ACPI_MOVE_16_TO_16(&DeviceInfo->AddressSizeOffset, &CurrentOffset);
         for (i = 0; *PFieldList && (i < DeviceInfo->RegisterCount); i++)
         {
             Status = DtCompileTable (PFieldList, AcpiDmTableInfoDbg2Size,
@@ -470,7 +483,7 @@ DtCompileDbg2 (
 
         /* NamespaceString device identifier (Required, size = NamePathLength) */
 
-        DeviceInfo->NamepathOffset = CurrentOffset;
+        ACPI_MOVE_16_TO_16(&DeviceInfo->NamepathOffset, &CurrentOffset);
         Status = DtCompileTable (PFieldList, AcpiDmTableInfoDbg2Name,
             &Subtable);
         if (ACPI_FAILURE (Status))
@@ -480,8 +493,9 @@ DtCompileDbg2 (
 
         /* Update the device info header */
 
-        DeviceInfo->NamepathLength = (UINT16) Subtable->Length;
-        CurrentOffset += (UINT16) DeviceInfo->NamepathLength;
+        ACPI_MOVE_32_TO_16(&DeviceInfo->NamepathLength, &Subtable->Length);
+        ACPI_MOVE_16_TO_16(&Tmp16, &DeviceInfo->NamepathLength);
+        CurrentOffset += Tmp16;
         DtInsertSubtable (ParentTable, Subtable);
 
         /* OemData - Variable-length data (Optional, size = OemDataLength) */
@@ -508,8 +522,8 @@ DtCompileDbg2 (
 
         if (Subtable && Subtable->Length)
         {
-            DeviceInfo->OemDataOffset = CurrentOffset;
-            DeviceInfo->OemDataLength = (UINT16) Subtable->Length;
+            ACPI_MOVE_16_TO_16(&DeviceInfo->OemDataOffset, &CurrentOffset);
+            ACPI_MOVE_32_TO_16(&DeviceInfo->OemDataLength, &Subtable->Length);
 
             DtInsertSubtable (ParentTable, Subtable);
         }
@@ -549,6 +563,8 @@ DtCompileDmar (
     ACPI_DMAR_DEVICE_SCOPE  *DmarDeviceScope;
     UINT32                  DeviceScopeLength;
     UINT32                  PciPathLength;
+    UINT16		    Tmp16;
+    UINT16		    HdrType;
 
 
     Status = DtCompileTable (PFieldList, AcpiDmTableInfoDmar, &Subtable);
@@ -578,8 +594,11 @@ DtCompileDmar (
         DtPushSubtable (Subtable);
 
         DmarHeader = ACPI_CAST_PTR (ACPI_DMAR_HEADER, Subtable->Buffer);
+	ACPI_MOVE_16_TO_16(&Tmp16, &DmarHeader->Length);
+	DmarHeader->Length = Tmp16;
 
-        switch (DmarHeader->Type)
+	ACPI_MOVE_16_TO_16(&HdrType, &DmarHeader->Type);
+        switch (HdrType)
         {
         case ACPI_DMAR_TYPE_HARDWARE_UNIT:
 
@@ -626,8 +645,8 @@ DtCompileDmar (
         /*
          * Optional Device Scope subtables
          */
-        if ((DmarHeader->Type == ACPI_DMAR_TYPE_HARDWARE_AFFINITY) ||
-            (DmarHeader->Type == ACPI_DMAR_TYPE_NAMESPACE))
+        if ((HdrType == ACPI_DMAR_TYPE_HARDWARE_AFFINITY) ||
+            (HdrType == ACPI_DMAR_TYPE_NAMESPACE))
         {
             /* These types do not support device scopes */
 
@@ -637,7 +656,7 @@ DtCompileDmar (
 
         DtPushSubtable (Subtable);
         DeviceScopeLength = DmarHeader->Length - Subtable->Length -
-            ParentTable->Length;
+		ParentTable->Length;
         while (DeviceScopeLength)
         {
             Status = DtCompileTable (PFieldList, AcpiDmTableInfoDmarScope,
@@ -762,7 +781,7 @@ DtCompileDrtm (
         Count++;
     }
 
-    DrtmVtl->ValidatedTableCount = Count;
+    ACPI_MOVE_32_TO_32(&DrtmVtl->ValidatedTableCount, &Count);
     DtPopSubtable ();
     ParentTable = DtPeekSubtable ();
 
@@ -800,7 +819,7 @@ DtCompileDrtm (
         Count++;
     }
 
-    DrtmRl->ResourceCount = Count;
+    ACPI_MOVE_32_TO_32(&DrtmRl->ResourceCount, &Count);
     DtPopSubtable ();
     ParentTable = DtPeekSubtable ();
 
@@ -895,6 +914,7 @@ DtCompileGtdt (
     ACPI_DMTABLE_INFO       *InfoTable;
     UINT32                  GtCount;
     ACPI_TABLE_HEADER       *Header;
+    ACPI_GTDT_TIMER_BLOCK   *TimerBlock;
 
 
     ParentTable = DtPeekSubtable ();
@@ -982,8 +1002,9 @@ DtCompileGtdt (
             DtPushSubtable (Subtable);
             ParentTable = DtPeekSubtable ();
 
-            GtCount = (ACPI_CAST_PTR (ACPI_GTDT_TIMER_BLOCK,
-                Subtable->Buffer - sizeof(ACPI_GTDT_HEADER)))->TimerCount;
+	    TimerBlock = ACPI_CAST_PTR (ACPI_GTDT_TIMER_BLOCK,
+                Subtable->Buffer - sizeof(ACPI_GTDT_HEADER));
+	    ACPI_MOVE_32_TO_32(&GtCount, &TimerBlock->TimerCount);
 
             while (GtCount)
             {
@@ -1036,6 +1057,7 @@ DtCompileFpdt (
     ACPI_DMTABLE_INFO       *InfoTable;
     DT_FIELD                **PFieldList = (DT_FIELD **) List;
     DT_FIELD                *SubtableStart;
+    UINT16		    HdrType;
 
 
     while (*PFieldList)
@@ -1054,7 +1076,8 @@ DtCompileFpdt (
 
         FpdtHeader = ACPI_CAST_PTR (ACPI_FPDT_HEADER, Subtable->Buffer);
 
-        switch (FpdtHeader->Type)
+	ACPI_MOVE_16_TO_16(&HdrType, &FpdtHeader->Type);
+        switch (HdrType)
         {
         case ACPI_FPDT_TYPE_BOOT:
 
@@ -1112,6 +1135,7 @@ DtCompileHest (
     ACPI_DMTABLE_INFO       *InfoTable;
     UINT16                  Type;
     UINT32                  BankCount;
+    UINT16		    Tmp16;
 
 
     Status = DtCompileTable (PFieldList, AcpiDmTableInfoHest,
@@ -1129,8 +1153,9 @@ DtCompileHest (
         /* Get subtable type */
 
         SubtableStart = *PFieldList;
-        DtCompileInteger ((UINT8 *) &Type, *PFieldList, 2, 0);
+        DtCompileInteger ((UINT8 *) &Tmp16, *PFieldList, 2, 0);
 
+	ACPI_MOVE_16_TO_16(&Type, &Tmp16);
         switch (Type)
         {
         case ACPI_HEST_TYPE_IA32_CHECK:
@@ -1480,11 +1505,13 @@ DtCompileIort (
     ACPI_IORT_SMMU          *IortSmmu;
     UINT32                  NodeNumber;
     UINT32                  NodeLength;
+    UINT32                  NodeOffset;
     UINT32                  IdMappingNumber;
     UINT32                  ItsNumber;
     UINT32                  ContextIrptNumber;
     UINT32                  PmuIrptNumber;
     UINT32                  PaddingLength;
+    UINT32                  MappingOffset;
 
 
     ParentTable = DtPeekSubtable ();
@@ -1510,7 +1537,7 @@ DtCompileIort (
      * Optionally allows the generic data types to be used for filling
      * this field.
      */
-    Iort->NodeOffset = sizeof (ACPI_TABLE_IORT);
+    NodeOffset = sizeof (ACPI_TABLE_IORT);
     Status = DtCompileTable (PFieldList, AcpiDmTableInfoIortPad,
         &Subtable);
     if (ACPI_FAILURE (Status))
@@ -1520,7 +1547,7 @@ DtCompileIort (
     if (Subtable)
     {
         DtInsertSubtable (ParentTable, Subtable);
-        Iort->NodeOffset += Subtable->Length;
+        NodeOffset += Subtable->Length;
     }
     else
     {
@@ -1530,8 +1557,9 @@ DtCompileIort (
         {
             return (Status);
         }
-        Iort->NodeOffset += PaddingLength;
+        NodeOffset += PaddingLength;
     }
+    ACPI_MOVE_32_TO_32(&Iort->NodeOffset, &NodeOffset);
 
     NodeNumber = 0;
     while (*PFieldList)
@@ -1585,7 +1613,7 @@ DtCompileIort (
                 ItsNumber++;
             }
 
-            IortItsGroup->ItsCount = ItsNumber;
+            ACPI_MOVE_32_TO_32(&IortItsGroup->ItsCount, &ItsNumber);
             break;
 
         case ACPI_IORT_NODE_NAMED_COMPONENT:
@@ -1619,15 +1647,16 @@ DtCompileIort (
             }
             else
             {
-                if (NodeLength > IortNode->MappingOffset)
+		ACPI_MOVE_32_TO_32(&MappingOffset, &IortNode->MappingOffset);
+                if (NodeLength > MappingOffset)
                 {
                     return (AE_BAD_DATA);
                 }
 
-                if (NodeLength < IortNode->MappingOffset)
+                if (NodeLength < MappingOffset)
                 {
                     Status = DtCompilePadding (
-                        IortNode->MappingOffset - NodeLength,
+                        MappingOffset - NodeLength,
                         &Subtable);
                     if (ACPI_FAILURE (Status))
                     {
@@ -1635,7 +1664,8 @@ DtCompileIort (
                     }
 
                     DtInsertSubtable (ParentTable, Subtable);
-                    NodeLength = IortNode->MappingOffset;
+		    ACPI_MOVE_32_TO_32(&MappingOffset, &IortNode->MappingOffset);
+                    NodeLength = MappingOffset;
                 }
             }
             break;
@@ -1668,7 +1698,7 @@ DtCompileIort (
 
             /* Compile global interrupt array */
 
-            IortSmmu->GlobalInterruptOffset = NodeLength;
+            ACPI_MOVE_32_TO_32(&IortSmmu->GlobalInterruptOffset, &NodeLength);
             Status = DtCompileTable (PFieldList, AcpiDmTableInfoIort3a,
                 &Subtable);
             if (ACPI_FAILURE (Status))
@@ -1682,7 +1712,7 @@ DtCompileIort (
             /* Compile context interrupt array */
 
             ContextIrptNumber = 0;
-            IortSmmu->ContextInterruptOffset = NodeLength;
+            ACPI_MOVE_32_TO_32(&IortSmmu->ContextInterruptOffset, &NodeLength);
             while (*PFieldList)
             {
                 Status = DtCompileTable (PFieldList, AcpiDmTableInfoIort3b,
@@ -1702,12 +1732,12 @@ DtCompileIort (
                 ContextIrptNumber++;
             }
 
-            IortSmmu->ContextInterruptCount = ContextIrptNumber;
+            ACPI_MOVE_32_TO_32(&IortSmmu->ContextInterruptCount, &ContextIrptNumber);
 
             /* Compile PMU interrupt array */
 
             PmuIrptNumber = 0;
-            IortSmmu->PmuInterruptOffset = NodeLength;
+            ACPI_MOVE_32_TO_32(&IortSmmu->PmuInterruptOffset, &NodeLength);
             while (*PFieldList)
             {
                 Status = DtCompileTable (PFieldList, AcpiDmTableInfoIort3c,
@@ -1727,7 +1757,7 @@ DtCompileIort (
                 PmuIrptNumber++;
             }
 
-            IortSmmu->PmuInterruptCount = PmuIrptNumber;
+            ACPI_MOVE_32_TO_32(&IortSmmu->PmuInterruptCount, &PmuIrptNumber);
             break;
 
         case ACPI_IORT_NODE_SMMU_V3:
@@ -1764,7 +1794,7 @@ DtCompileIort (
 
         /* Compile Array of ID mappings */
 
-        IortNode->MappingOffset = NodeLength;
+        ACPI_MOVE_32_TO_32(&IortNode->MappingOffset, &NodeLength);
         IdMappingNumber = 0;
         while (*PFieldList)
         {
@@ -1785,7 +1815,7 @@ DtCompileIort (
             IdMappingNumber++;
         }
 
-        IortNode->MappingCount = IdMappingNumber;
+        ACPI_MOVE_32_TO_32(&IortNode->MappingCount, &IdMappingNumber);
         if (!IdMappingNumber)
         {
             IortNode->MappingOffset = 0;
@@ -1800,7 +1830,7 @@ DtCompileIort (
         NodeNumber++;
     }
 
-    Iort->NodeCount = NodeNumber;
+    ACPI_MOVE_32_TO_32(&Iort->NodeCount, &NodeNumber);
     return (AE_OK);
 }
 
Index: acpica-unix-20191213/source/compiler/dttable2.c
===================================================================
--- acpica-unix-20191213.orig/source/compiler/dttable2.c
+++ acpica-unix-20191213/source/compiler/dttable2.c
@@ -345,7 +345,7 @@ DtCompileMpst (
     DtPushSubtable (Subtable);
 
     MpstChannelInfo = ACPI_CAST_PTR (ACPI_MPST_CHANNEL, Subtable->Buffer);
-    SubtableCount = MpstChannelInfo->PowerNodeCount;
+    ACPI_MOVE_16_TO_16(&SubtableCount, &MpstChannelInfo->PowerNodeCount);
 
     while (*PFieldList && SubtableCount)
     {
@@ -363,8 +363,8 @@ DtCompileMpst (
         DtPushSubtable (Subtable);
 
         MpstPowerNode = ACPI_CAST_PTR (ACPI_MPST_POWER_NODE, Subtable->Buffer);
-        PowerStateCount = MpstPowerNode->NumPowerStates;
-        ComponentCount = MpstPowerNode->NumPhysicalComponents;
+        ACPI_MOVE_32_TO_32(&PowerStateCount, &MpstPowerNode->NumPowerStates);
+        ACPI_MOVE_32_TO_32(&ComponentCount, &MpstPowerNode->NumPhysicalComponents);
 
         ParentTable = DtPeekSubtable ();
 
@@ -517,6 +517,7 @@ DtCompileNfit (
     UINT32                  Count;
     ACPI_NFIT_INTERLEAVE    *Interleave = NULL;
     ACPI_NFIT_FLUSH_ADDRESS *Hint = NULL;
+    UINT16		    SubType;
 
 
     /* Main table */
@@ -550,7 +551,8 @@ DtCompileNfit (
 
         NfitHeader = ACPI_CAST_PTR (ACPI_NFIT_HEADER, Subtable->Buffer);
 
-        switch (NfitHeader->Type)
+	ACPI_MOVE_16_TO_16(&SubType, &NfitHeader->Type);
+        switch (SubType)
         {
         case ACPI_NFIT_TYPE_SYSTEM_ADDRESS:
 
@@ -610,7 +612,7 @@ DtCompileNfit (
         DtInsertSubtable (ParentTable, Subtable);
         DtPopSubtable ();
 
-        switch (NfitHeader->Type)
+        switch (SubType)
         {
         case ACPI_NFIT_TYPE_INTERLEAVE:
 
@@ -636,7 +638,7 @@ DtCompileNfit (
                 Count++;
             }
 
-            Interleave->LineCount = Count;
+            ACPI_MOVE_32_TO_32(&Interleave->LineCount, &Count);
             break;
 
         case ACPI_NFIT_TYPE_SMBIOS:
@@ -681,7 +683,7 @@ DtCompileNfit (
                 Count++;
             }
 
-            Hint->HintCount = (UINT16) Count;
+            ACPI_MOVE_32_TO_16(&Hint->HintCount, &Count);
             break;
 
         default:
@@ -957,7 +959,7 @@ DtCompilePmtt (
 
             PmttController = ACPI_CAST_PTR (ACPI_PMTT_CONTROLLER,
                 (Subtable->Buffer - sizeof (ACPI_PMTT_HEADER)));
-            DomainCount = PmttController->DomainCount;
+            ACPI_MOVE_16_TO_16(&DomainCount, &PmttController->DomainCount);
 
             while (DomainCount)
             {
@@ -1177,6 +1179,7 @@ DtCompileS3pt (
     DT_SUBTABLE             *ParentTable;
     ACPI_DMTABLE_INFO       *InfoTable;
     DT_FIELD                *SubtableStart;
+    UINT16		    HdrType;
 
 
     Status = DtCompileTable (PFieldList, AcpiDmTableInfoS3pt,
@@ -1204,7 +1207,8 @@ DtCompileS3pt (
 
         S3ptHeader = ACPI_CAST_PTR (ACPI_FPDT_HEADER, Subtable->Buffer);
 
-        switch (S3ptHeader->Type)
+	ACPI_MOVE_16_TO_16(&HdrType, &S3ptHeader->Type);
+        switch (HdrType)
         {
         case ACPI_S3PT_TYPE_RESUME:
 
@@ -1517,6 +1521,7 @@ DtCompileSlit (
     UINT32                  Localities;
     UINT32                  LocalityListLength;
     UINT8                   *LocalityBuffer;
+    UINT32		    Tmp;
 
 
     Status = DtCompileTable (PFieldList, AcpiDmTableInfoSlit,
@@ -1529,7 +1534,8 @@ DtCompileSlit (
     ParentTable = DtPeekSubtable ();
     DtInsertSubtable (ParentTable, Subtable);
 
-    Localities = *ACPI_CAST_PTR (UINT32, Subtable->Buffer);
+    Tmp = *ACPI_CAST_PTR (UINT32, Subtable->Buffer);
+    ACPI_MOVE_32_TO_32(&Localities, &Tmp);
     LocalityBuffer = UtLocalCalloc (Localities);
     LocalityListLength = 0;
 
@@ -1741,6 +1747,7 @@ DtCompileTcpa (
     ACPI_TABLE_TCPA_HDR     *TcpaHeader;
     DT_SUBTABLE             *ParentTable;
     ACPI_STATUS             Status;
+    UINT16		    PlatClass;
 
 
     /* Compile the main table */
@@ -1761,7 +1768,8 @@ DtCompileTcpa (
      */
     TcpaHeader = ACPI_CAST_PTR (ACPI_TABLE_TCPA_HDR, ParentTable->Buffer);
 
-    switch (TcpaHeader->PlatformClass)
+    ACPI_MOVE_16_TO_16(&PlatClass, &TcpaHeader->PlatformClass);
+    switch (PlatClass)
     {
     case ACPI_TCPA_CLIENT_TABLE:
 
@@ -1809,6 +1817,7 @@ DtCompileTpm2Rev3 (
     ACPI_TABLE_TPM23        *Tpm23Header;
     DT_SUBTABLE             *ParentTable;
     ACPI_STATUS             Status = AE_OK;
+    UINT32		    Tmp32;
 
 
     Status = DtCompileTable (PFieldList, AcpiDmTableInfoTpm23,
@@ -1820,7 +1829,8 @@ DtCompileTpm2Rev3 (
 
     /* Subtable type depends on the StartMethod */
 
-    switch (Tpm23Header->StartMethod)
+    ACPI_MOVE_32_TO_32(&Tmp32, &Tpm23Header->StartMethod);
+    switch (Tmp32)
     {
     case ACPI_TPM23_ACPI_START_METHOD:
 
@@ -1867,6 +1877,7 @@ DtCompileTpm2 (
     DT_SUBTABLE             *ParentTable;
     ACPI_STATUS             Status = AE_OK;
     ACPI_TABLE_HEADER       *Header;
+    UINT32		    Tmp32;
 
 
     ParentTable = DtPeekSubtable ();
@@ -1910,7 +1921,8 @@ DtCompileTpm2 (
 
     /* Subtable type depends on the StartMethod */
 
-    switch (Tpm2Header->StartMethod)
+    ACPI_MOVE_32_TO_32(&Tmp32, &Tpm2Header->StartMethod);
+    switch (Tmp32)
     {
     case ACPI_TPM2_COMMAND_BUFFER_WITH_ARM_SMC:
 
@@ -2126,6 +2138,9 @@ DtCompileWpbt (
     ACPI_TABLE_WPBT         *Table;
     ACPI_STATUS             Status;
     UINT16                  Length;
+    UINT16                  Tmp16;
+    UINT16		    *Ptr16;
+    UINT32		    ii;
 
 
     /* Compile the main table */
@@ -2153,7 +2168,16 @@ DtCompileWpbt (
 
     Length = (UINT16) Subtable->TotalLength;
     Table = ACPI_CAST_PTR (ACPI_TABLE_WPBT, ParentTable->Buffer);
-    Table->ArgumentsLength = Length;
+    ACPI_MOVE_16_TO_16(&Table->ArgumentsLength, &Length);
+
+    /* The arguments are in Unicode, so make sure the byte order is correct */
+    Ptr16 = (UINT16 *)Subtable->Buffer;
+    for (ii = 0; ii < Length; ii++)
+    {
+	ACPI_MOVE_16_TO_16(&Tmp16, Ptr16);
+	*Ptr16 = Tmp16;
+        Ptr16++;
+    }
 
     ParentTable = DtPeekSubtable ();
     DtInsertSubtable (ParentTable, Subtable);
Index: acpica-unix-20191213/source/components/disassembler/dmbuffer.c
===================================================================
--- acpica-unix-20191213.orig/source/components/disassembler/dmbuffer.c
+++ acpica-unix-20191213/source/components/disassembler/dmbuffer.c
@@ -204,7 +204,7 @@ AcpiDmByteList (
 
 
     ByteData = Op->Named.Data;
-    ByteCount = (UINT32) Op->Common.Value.Integer;
+    ByteCount = (UINT32) Op->Common.Value.Size;
 
     /*
      * The byte list belongs to a buffer, and can be produced by either
@@ -304,7 +304,8 @@ AcpiDmIsUuidBuffer (
     /* Extract the byte list info */
 
     ByteData = NextOp->Named.Data;
-    ByteCount = (UINT32) NextOp->Common.Value.Integer;
+    /* ByteCount = (UINT32) NextOp->Common.Value.Integer; */
+    ByteCount = (UINT32) NextOp->Common.Value.Size;
 
     /* Byte count must be exactly 16 */
 
@@ -424,7 +425,8 @@ AcpiDmIsUnicodeBuffer (
     /* Extract the byte list info */
 
     ByteData = NextOp->Named.Data;
-    ByteCount = (UINT32) NextOp->Common.Value.Integer;
+    /* ByteCount = (UINT32) NextOp->Common.Value.Integer; */
+    ByteCount = (UINT32) NextOp->Common.Value.Size;
     WordCount = ACPI_DIV_2 (ByteCount);
 
     /*
@@ -852,19 +854,22 @@ AcpiDmUnicode (
     UINT32                  WordCount;
     UINT32                  i;
     int                     OutputValue;
+    UINT16		    Tmp16;
 
 
     /* Extract the buffer info as a WORD buffer */
 
     WordData = ACPI_CAST_PTR (UINT16, Op->Named.Data);
-    WordCount = ACPI_DIV_2 (((UINT32) Op->Common.Value.Integer));
+    WordCount = ACPI_DIV_2 (((UINT32) Op->Common.Value.Size));
 
     /* Write every other byte as an ASCII character */
 
     AcpiOsPrintf ("\"");
     for (i = 0; i < (WordCount - 1); i++)
     {
-        OutputValue = (int) WordData[i];
+        /* OutputValue = (int) WordData[i]; */
+	ACPI_MOVE_16_TO_16(&Tmp16, &WordData[i]);
+	OutputValue = (int) Tmp16;
 
         /* Handle values that must be escaped */
 
@@ -973,16 +978,18 @@ AcpiDmCheckForHardwareId (
     ACPI_PARSE_OBJECT       *Op)
 {
     UINT32                  Name;
+    UINT32                  TmpName;
     ACPI_PARSE_OBJECT       *NextOp;
 
 
     /* Get the NameSegment */
 
-    Name = AcpiPsGetName (Op);
-    if (!Name)
+    TmpName = AcpiPsGetName (Op);
+    if (!TmpName)
     {
         return;
     }
+    ACPI_MOVE_32_TO_32(&Name, &TmpName);
 
     NextOp = AcpiPsGetDepthNext (NULL, Op);
     if (!NextOp)
Index: acpica-unix-20191213/source/components/disassembler/dmopcode.c
===================================================================
--- acpica-unix-20191213.orig/source/components/disassembler/dmopcode.c
+++ acpica-unix-20191213/source/components/disassembler/dmopcode.c
@@ -244,6 +244,7 @@ AcpiDmPredefinedDescription (
     char                        *NameString;
     int                         LastCharIsDigit;
     int                         LastCharsAreHex;
+    char			TmpName[ACPI_NAMESEG_SIZE + 1];
 
 
     if (!Op)
@@ -261,7 +262,9 @@ AcpiDmPredefinedDescription (
 
     /* Predefined name must start with an underscore */
 
-    NameString = ACPI_CAST_PTR (char, &Op->Named.Name);
+    memset(TmpName, 0, ACPI_NAMESEG_SIZE + 1);
+    ACPI_MOVE_32_TO_32(TmpName, &Op->Named.Name);
+    NameString = TmpName;
     if (NameString[0] != '_')
     {
         return;
@@ -880,25 +883,29 @@ AcpiDmDisassembleOneOp (
         AcpiDmNamestring (Op->Common.Value.Name);
         break;
 
-    case AML_INT_NAMEDFIELD_OP:
+    case AML_INT_NAMEDFIELD_OP: {
 
-        Length = AcpiDmDumpName (Op->Named.Name);
+	UINT32 TmpName;
+
+	ACPI_MOVE_32_TO_32(&TmpName, &Op->Named.Name);
+        Length = AcpiDmDumpName (TmpName);
 
         AcpiOsPrintf (",");
         ASL_CV_PRINT_ONE_COMMENT (Op, AML_NAMECOMMENT, NULL, 0);
         AcpiOsPrintf ("%*.s  %u", (unsigned) (5 - Length), " ",
-            (UINT32) Op->Common.Value.Integer);
+            (UINT32) Op->Common.Value.Size);
 
         AcpiDmCommaIfFieldMember (Op);
 
-        Info->BitOffset += (UINT32) Op->Common.Value.Integer;
+        Info->BitOffset += (UINT32) Op->Common.Value.Size;
         break;
+    }
 
     case AML_INT_RESERVEDFIELD_OP:
 
         /* Offset() -- Must account for previous offsets */
 
-        Offset = (UINT32) Op->Common.Value.Integer;
+        Offset = Op->Common.Value.Size;
         Info->BitOffset += Offset;
 
         if (Info->BitOffset % 8 == 0)
@@ -942,10 +949,15 @@ AcpiDmDisassembleOneOp (
 
         if (Child->Common.AmlOpcode == AML_INT_BYTELIST_OP)
         {
+	    /* UINT64 Tmp64; */
+
             AcpiOsPrintf ("\n");
 
             Aml = Child->Named.Data;
+	    /*
             Length = (UINT32) Child->Common.Value.Integer;
+	    */
+            Length = (UINT32) Child->Common.Value.Size;
 
             Info->Level += 1;
             Info->MappingOp = Op;
Index: acpica-unix-20191213/source/components/disassembler/dmresrcl.c
===================================================================
--- acpica-unix-20191213.orig/source/components/disassembler/dmresrcl.c
+++ acpica-unix-20191213/source/components/disassembler/dmresrcl.c
@@ -141,7 +141,8 @@ AcpiDmMemoryFields (
     UINT32                  Level)
 {
     UINT32                  i;
-
+    UINT16		    Tmp16;
+    UINT32		    Tmp32;
 
     for (i = 0; i < 4; i++)
     {
@@ -151,14 +152,14 @@ AcpiDmMemoryFields (
         {
         case 16:
 
-            AcpiDmDumpInteger16 (ACPI_CAST_PTR (UINT16, Source)[i],
-                AcpiDmMemoryNames[i]);
+	    ACPI_MOVE_16_TO_16(&Tmp16, &(ACPI_CAST_PTR (UINT16, Source)[i]));
+            AcpiDmDumpInteger16 (Tmp16, AcpiDmMemoryNames[i]);
             break;
 
         case 32:
 
-            AcpiDmDumpInteger32 (ACPI_CAST_PTR (UINT32, Source)[i],
-                AcpiDmMemoryNames[i]);
+	    ACPI_MOVE_32_TO_32(&Tmp32, &(ACPI_CAST_PTR (UINT32, Source)[i]));
+            AcpiDmDumpInteger32 (Tmp32, AcpiDmMemoryNames[i]);
             break;
 
         default:
@@ -190,7 +191,9 @@ AcpiDmAddressFields (
     UINT32                  Level)
 {
     UINT32                  i;
-
+    UINT16		    Tmp16;
+    UINT32		    Tmp32;
+    UINT64		    Tmp64;
 
     AcpiOsPrintf ("\n");
 
@@ -202,20 +205,20 @@ AcpiDmAddressFields (
         {
         case 16:
 
-            AcpiDmDumpInteger16 (ACPI_CAST_PTR (UINT16, Source)[i],
-                AcpiDmAddressNames[i]);
+	    ACPI_MOVE_16_TO_16(&Tmp16, &(ACPI_CAST_PTR (UINT16, Source)[i]));
+            AcpiDmDumpInteger16 (Tmp16, AcpiDmAddressNames[i]);
             break;
 
         case 32:
 
-            AcpiDmDumpInteger32 (ACPI_CAST_PTR (UINT32, Source)[i],
-                AcpiDmAddressNames[i]);
+	    ACPI_MOVE_32_TO_32(&Tmp32, &(ACPI_CAST_PTR (UINT32, Source)[i]));
+            AcpiDmDumpInteger32 (Tmp32, AcpiDmAddressNames[i]);
             break;
 
         case 64:
 
-            AcpiDmDumpInteger64 (ACPI_CAST_PTR (UINT64, Source)[i],
-                AcpiDmAddressNames[i]);
+	    ACPI_MOVE_64_TO_64(&Tmp64, &(ACPI_CAST_PTR (UINT64, Source)[i]));
+            AcpiDmDumpInteger64 (Tmp64, AcpiDmAddressNames[i]);
             break;
 
         default:
@@ -868,6 +871,7 @@ AcpiDmFixedMemory32Descriptor (
     UINT32                  Length,
     UINT32                  Level)
 {
+    UINT32 Tmp;
 
     /* Dump name and read/write flag */
 
@@ -876,12 +880,12 @@ AcpiDmFixedMemory32Descriptor (
         AcpiGbl_RwDecode [ACPI_GET_1BIT_FLAG (Resource->FixedMemory32.Flags)]);
 
     AcpiDmIndent (Level + 1);
-    AcpiDmDumpInteger32 (Resource->FixedMemory32.Address,
-        "Address Base");
+    ACPI_MOVE_32_TO_32(&Tmp, &Resource->FixedMemory32.Address);
+    AcpiDmDumpInteger32 (Tmp, "Address Base");
 
     AcpiDmIndent (Level + 1);
-    AcpiDmDumpInteger32 (Resource->FixedMemory32.AddressLength,
-        "Address Length");
+    ACPI_MOVE_32_TO_32(&Tmp, &Resource->FixedMemory32.AddressLength);
+    AcpiDmDumpInteger32 (Tmp, "Address Length");
 
     /* Insert a descriptor name */
 
@@ -913,6 +917,7 @@ AcpiDmGenericRegisterDescriptor (
     UINT32                  Length,
     UINT32                  Level)
 {
+    UINT64		    Tmp64;
 
     AcpiDmIndent (Level);
     AcpiOsPrintf ("Register (");
@@ -926,7 +931,9 @@ AcpiDmGenericRegisterDescriptor (
     AcpiDmDumpInteger8 (Resource->GenericReg.BitOffset, "Bit Offset");
 
     AcpiDmIndent (Level + 1);
-    AcpiDmDumpInteger64 (Resource->GenericReg.Address, "Address");
+    /* AcpiDmDumpInteger64 (Resource->GenericReg.Address, "Address"); */
+    ACPI_MOVE_64_TO_64(&Tmp64, &Resource->GenericReg.Address);
+    AcpiDmDumpInteger64 (Tmp64, "Address");
 
     /* Optional field for ACPI 3.0 */
 
@@ -972,7 +979,7 @@ AcpiDmInterruptDescriptor (
     UINT32                  Level)
 {
     UINT32                  i;
-
+    UINT16		    Tmp16;
 
     AcpiDmIndent (Level);
     AcpiOsPrintf ("Interrupt (%s, %s, %s, %s, ",
@@ -986,10 +993,11 @@ AcpiDmInterruptDescriptor (
      * list. Must compute length based on length of the list. First xrupt
      * is included in the struct (reason for -1 below)
      */
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->ExtendedIrq.ResourceLength);
     AcpiDmResourceSource (Resource,
         sizeof (AML_RESOURCE_EXTENDED_IRQ) +
             ((UINT32) Resource->ExtendedIrq.InterruptCount - 1) * sizeof (UINT32),
-        Resource->ExtendedIrq.ResourceLength);
+        Tmp16);
 
     /* Insert a descriptor name */
 
@@ -1002,9 +1010,12 @@ AcpiDmInterruptDescriptor (
     AcpiOsPrintf ("{\n");
     for (i = 0; i < Resource->ExtendedIrq.InterruptCount; i++)
     {
+	UINT32 Tmp32, Val32;
+
         AcpiDmIndent (Level + 1);
-        AcpiOsPrintf ("0x%8.8X,\n",
-            (UINT32) Resource->ExtendedIrq.Interrupts[i]);
+	Val32 = (UINT32) Resource->ExtendedIrq.Interrupts[i];
+	ACPI_MOVE_32_TO_32(&Tmp32, &Val32);
+        AcpiOsPrintf ("0x%8.8X,\n", Tmp32);
     }
 
     AcpiDmIndent (Level);
Index: acpica-unix-20191213/source/components/disassembler/dmresrcl2.c
===================================================================
--- acpica-unix-20191213.orig/source/components/disassembler/dmresrcl2.c
+++ acpica-unix-20191213/source/components/disassembler/dmresrcl2.c
@@ -191,22 +191,24 @@ AcpiDmGpioCommon (
     char                    *DeviceName = NULL;
     UINT32                  PinCount;
     UINT32                  i;
+    UINT16		    Tmp16;
 
 
     /* ResourceSource, ResourceSourceIndex, ResourceType */
 
     AcpiDmIndent (Level + 1);
-    if (Resource->Gpio.ResSourceOffset)
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->Gpio.ResSourceOffset);
+    if (Tmp16)
     {
-        DeviceName = ACPI_ADD_PTR (char,
-            Resource, Resource->Gpio.ResSourceOffset),
+        DeviceName = ACPI_ADD_PTR (char, Resource, Tmp16),
         AcpiUtPrintString (DeviceName, ACPI_UINT16_MAX);
     }
 
     AcpiOsPrintf (", ");
     AcpiOsPrintf ("0x%2.2X, ", Resource->Gpio.ResSourceIndex);
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->Gpio.Flags);
     AcpiOsPrintf ("%s, ",
-        AcpiGbl_ConsumeDecode [ACPI_GET_1BIT_FLAG (Resource->Gpio.Flags)]);
+        AcpiGbl_ConsumeDecode [ACPI_GET_1BIT_FLAG (Tmp16)]);
 
     /* Insert a descriptor name */
 
@@ -215,15 +217,16 @@ AcpiDmGpioCommon (
 
     /* Dump the vendor data */
 
-    if (Resource->Gpio.VendorOffset)
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->Gpio.VendorOffset);
+    if (Tmp16)
     {
         AcpiOsPrintf ("\n");
         AcpiDmIndent (Level + 1);
-        VendorData = ACPI_ADD_PTR (UINT8, Resource,
-            Resource->Gpio.VendorOffset);
+	ACPI_MOVE_16_TO_16(&Tmp16, &Resource->Gpio.VendorOffset);
+        VendorData = ACPI_ADD_PTR (UINT8, Resource, Tmp16);
 
-        AcpiDmDumpRawDataBuffer (VendorData,
-            Resource->Gpio.VendorLength, Level);
+	ACPI_MOVE_16_TO_16(&Tmp16, &Resource->Gpio.VendorLength);
+        AcpiDmDumpRawDataBuffer (VendorData, Tmp16, Level);
     }
 
     AcpiOsPrintf (")\n");
@@ -233,17 +236,25 @@ AcpiDmGpioCommon (
     AcpiDmIndent (Level + 1);
     AcpiOsPrintf ("{   // Pin list\n");
 
+    /*
     PinCount = ((UINT32) (Resource->Gpio.ResSourceOffset -
         Resource->Gpio.PinTableOffset)) /
         sizeof (UINT16);
+    */
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->Gpio.ResSourceOffset);
+    PinCount = (UINT32) Tmp16;
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->Gpio.PinTableOffset);
+    PinCount -= (UINT32) Tmp16;
+    PinCount /= sizeof (UINT16);
 
-    PinList = (UINT16 *) ACPI_ADD_PTR (char, Resource,
-        Resource->Gpio.PinTableOffset);
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->Gpio.PinTableOffset);
+    PinList = (UINT16 *) ACPI_ADD_PTR (char, Resource, Tmp16);
 
     for (i = 0; i < PinCount; i++)
     {
         AcpiDmIndent (Level + 2);
-        AcpiOsPrintf ("0x%4.4X%s\n", PinList[i],
+	ACPI_MOVE_16_TO_16(&Tmp16, &PinList[i]);
+        AcpiOsPrintf ("0x%4.4X%s\n", Tmp16,
             ((i + 1) < PinCount) ? "," : "");
     }
 
@@ -277,16 +288,18 @@ AcpiDmGpioIntDescriptor (
     UINT32                  Length,
     UINT32                  Level)
 {
+    UINT16		    Tmp16;
 
     /* Dump the GpioInt-specific portion of the descriptor */
 
     /* EdgeLevel, ActiveLevel, Shared */
 
     AcpiDmIndent (Level);
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->Gpio.IntFlags);
     AcpiOsPrintf ("GpioInt (%s, %s, %s, ",
-        AcpiGbl_HeDecode [ACPI_GET_1BIT_FLAG (Resource->Gpio.IntFlags)],
-        AcpiGbl_LlDecode [ACPI_EXTRACT_2BIT_FLAG (Resource->Gpio.IntFlags, 1)],
-        AcpiGbl_ShrDecode [ACPI_EXTRACT_2BIT_FLAG (Resource->Gpio.IntFlags, 3)]);
+        AcpiGbl_HeDecode [ACPI_GET_1BIT_FLAG (Tmp16)],
+        AcpiGbl_LlDecode [ACPI_EXTRACT_2BIT_FLAG (Tmp16, 1)],
+        AcpiGbl_ShrDecode [ACPI_EXTRACT_2BIT_FLAG (Tmp16, 3)]);
 
     /* PinConfig, DebounceTimeout */
 
@@ -299,7 +312,8 @@ AcpiDmGpioIntDescriptor (
     {
         AcpiOsPrintf ("0x%2.2X, ", Resource->Gpio.PinConfig);
     }
-    AcpiOsPrintf ("0x%4.4X,\n", Resource->Gpio.DebounceTimeout);
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->Gpio.DebounceTimeout);
+    AcpiOsPrintf ("0x%4.4X,\n", Tmp16);
 
     /* Dump the GpioInt/GpioIo common portion of the descriptor */
 
@@ -329,14 +343,16 @@ AcpiDmGpioIoDescriptor (
     UINT32                  Length,
     UINT32                  Level)
 {
+    UINT16		    Tmp16;
 
     /* Dump the GpioIo-specific portion of the descriptor */
 
     /* Shared, PinConfig */
 
     AcpiDmIndent (Level);
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->Gpio.IntFlags);
     AcpiOsPrintf ("GpioIo (%s, ",
-        AcpiGbl_ShrDecode [ACPI_EXTRACT_2BIT_FLAG (Resource->Gpio.IntFlags, 3)]);
+        AcpiGbl_ShrDecode [ACPI_EXTRACT_2BIT_FLAG (Tmp16, 3)]);
 
     if (Resource->Gpio.PinConfig <= 3)
     {
@@ -350,10 +366,13 @@ AcpiDmGpioIoDescriptor (
 
     /* DebounceTimeout, DriveStrength, IoRestriction */
 
-    AcpiOsPrintf ("0x%4.4X, ", Resource->Gpio.DebounceTimeout);
-    AcpiOsPrintf ("0x%4.4X, ", Resource->Gpio.DriveStrength);
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->Gpio.DebounceTimeout);
+    AcpiOsPrintf ("0x%4.4X, ", Tmp16);
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->Gpio.DriveStrength);
+    AcpiOsPrintf ("0x%4.4X, ", Tmp16);
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->Gpio.IntFlags);
     AcpiOsPrintf ("%s,\n",
-        AcpiGbl_IorDecode [ACPI_GET_2BIT_FLAG (Resource->Gpio.IntFlags)]);
+        AcpiGbl_IorDecode [ACPI_GET_2BIT_FLAG (Tmp16)]);
 
     /* Dump the GpioInt/GpioIo common portion of the descriptor */
 
@@ -533,6 +552,7 @@ AcpiDmDumpSerialBusVendorData (
 {
     UINT8                   *VendorData;
     UINT32                  VendorLength;
+    UINT16                  Tmp16;
 
 
     /* Get the (optional) vendor data and length */
@@ -541,8 +561,8 @@ AcpiDmDumpSerialBusVendorData (
     {
     case AML_RESOURCE_I2C_SERIALBUSTYPE:
 
-        VendorLength = Resource->CommonSerialBus.TypeDataLength -
-            AML_RESOURCE_I2C_MIN_DATA_LEN;
+	ACPI_MOVE_16_TO_16(&Tmp16, &Resource->CommonSerialBus.TypeDataLength);
+        VendorLength = Tmp16 - AML_RESOURCE_I2C_MIN_DATA_LEN;
 
         VendorData = ACPI_ADD_PTR (UINT8, Resource,
             sizeof (AML_RESOURCE_I2C_SERIALBUS));
@@ -550,8 +570,8 @@ AcpiDmDumpSerialBusVendorData (
 
     case AML_RESOURCE_SPI_SERIALBUSTYPE:
 
-        VendorLength = Resource->CommonSerialBus.TypeDataLength -
-            AML_RESOURCE_SPI_MIN_DATA_LEN;
+	ACPI_MOVE_16_TO_16(&Tmp16, &Resource->CommonSerialBus.TypeDataLength);
+        VendorLength = Tmp16 - AML_RESOURCE_SPI_MIN_DATA_LEN;
 
         VendorData = ACPI_ADD_PTR (UINT8, Resource,
             sizeof (AML_RESOURCE_SPI_SERIALBUS));
@@ -559,8 +579,8 @@ AcpiDmDumpSerialBusVendorData (
 
     case AML_RESOURCE_UART_SERIALBUSTYPE:
 
-        VendorLength = Resource->CommonSerialBus.TypeDataLength -
-            AML_RESOURCE_UART_MIN_DATA_LEN;
+	ACPI_MOVE_16_TO_16(&Tmp16, &Resource->CommonSerialBus.TypeDataLength);
+        VendorLength = Tmp16 - AML_RESOURCE_UART_MIN_DATA_LEN;
 
         VendorData = ACPI_ADD_PTR (UINT8, Resource,
             sizeof (AML_RESOURCE_UART_SERIALBUS));
@@ -601,24 +621,29 @@ AcpiDmI2cSerialBusDescriptor (
 {
     UINT32                  ResourceSourceOffset;
     char                    *DeviceName;
+    UINT16		    Tmp16;
+    UINT32		    Tmp32;
 
 
     /* SlaveAddress, SlaveMode, ConnectionSpeed, AddressingMode */
 
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->I2cSerialBus.SlaveAddress);
+    ACPI_MOVE_32_TO_32(&Tmp32, &Resource->I2cSerialBus.ConnectionSpeed);
     AcpiDmIndent (Level);
     AcpiOsPrintf ("I2cSerialBusV2 (0x%4.4X, %s, 0x%8.8X,\n",
-        Resource->I2cSerialBus.SlaveAddress,
+        Tmp16,
         AcpiGbl_SmDecode [ACPI_GET_1BIT_FLAG (Resource->I2cSerialBus.Flags)],
-        Resource->I2cSerialBus.ConnectionSpeed);
+        Tmp32);
 
     AcpiDmIndent (Level + 1);
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->I2cSerialBus.TypeSpecificFlags);
     AcpiOsPrintf ("%s, ",
-        AcpiGbl_AmDecode [ACPI_GET_1BIT_FLAG (Resource->I2cSerialBus.TypeSpecificFlags)]);
+        AcpiGbl_AmDecode [ACPI_GET_1BIT_FLAG (Tmp16)]);
 
     /* ResourceSource is a required field */
 
-    ResourceSourceOffset = sizeof (AML_RESOURCE_COMMON_SERIALBUS) +
-        Resource->CommonSerialBus.TypeDataLength;
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->CommonSerialBus.TypeDataLength);
+    ResourceSourceOffset = sizeof (AML_RESOURCE_COMMON_SERIALBUS) + Tmp16;
 
     DeviceName = ACPI_ADD_PTR (char, Resource, ResourceSourceOffset);
     AcpiUtPrintString (DeviceName, ACPI_UINT16_MAX);
Index: acpica-unix-20191213/source/components/disassembler/dmresrcs.c
===================================================================
--- acpica-unix-20191213.orig/source/components/disassembler/dmresrcs.c
+++ acpica-unix-20191213/source/components/disassembler/dmresrcs.c
@@ -72,6 +72,7 @@ AcpiDmIrqDescriptor (
     UINT32                  Length,
     UINT32                  Level)
 {
+    UINT16 Tmp;
 
     AcpiDmIndent (Level);
     AcpiOsPrintf ("%s (",
@@ -93,7 +94,8 @@ AcpiDmIrqDescriptor (
     AcpiOsPrintf (")\n");
 
     AcpiDmIndent (Level + 1);
-    AcpiDmBitList (Resource->Irq.IrqMask);
+    ACPI_MOVE_16_TO_16(&Tmp, &Resource->Irq.IrqMask);
+    AcpiDmBitList (Tmp);
 }
 
 
@@ -204,16 +206,19 @@ AcpiDmIoDescriptor (
     UINT32                  Length,
     UINT32                  Level)
 {
+    UINT16 Tmp16;
 
     AcpiDmIndent (Level);
     AcpiOsPrintf ("IO (%s,\n",
         AcpiGbl_IoDecode [ACPI_GET_1BIT_FLAG (Resource->Io.Flags)]);
 
     AcpiDmIndent (Level + 1);
-    AcpiDmDumpInteger16 (Resource->Io.Minimum, "Range Minimum");
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->Io.Minimum);
+    AcpiDmDumpInteger16 (Tmp16, "Range Minimum");
 
     AcpiDmIndent (Level + 1);
-    AcpiDmDumpInteger16 (Resource->Io.Maximum, "Range Maximum");
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->Io.Maximum);
+    AcpiDmDumpInteger16 (Tmp16, "Range Maximum");
 
     AcpiDmIndent (Level + 1);
     AcpiDmDumpInteger8 (Resource->Io.Alignment, "Alignment");
@@ -251,12 +256,14 @@ AcpiDmFixedIoDescriptor (
     UINT32                  Length,
     UINT32                  Level)
 {
+    UINT16                  Tmp16;
 
     AcpiDmIndent (Level);
     AcpiOsPrintf ("FixedIO (\n");
 
     AcpiDmIndent (Level + 1);
-    AcpiDmDumpInteger16 (Resource->FixedIo.Address, "Address");
+    ACPI_MOVE_16_TO_16(&Tmp16, &Resource->FixedIo.Address);
+    AcpiDmDumpInteger16 (Tmp16, "Address");
 
     AcpiDmIndent (Level + 1);
     AcpiDmDumpInteger8 (Resource->FixedIo.AddressLength, "Length");
Index: acpica-unix-20191213/source/components/dispatcher/dsfield.c
===================================================================
--- acpica-unix-20191213.orig/source/components/dispatcher/dsfield.c
+++ acpica-unix-20191213/source/components/dispatcher/dsfield.c
@@ -324,6 +324,7 @@ AcpiDsGetFieldNames (
     ACPI_STATUS             Status;
     UINT64                  Position;
     ACPI_PARSE_OBJECT       *Child;
+    UINT32 TmpName;
 
 #ifdef ACPI_EXEC_APP
     ACPI_OPERAND_OBJECT     *ResultDesc;
@@ -437,10 +438,17 @@ AcpiDsGetFieldNames (
 
             /* Lookup the name, it should already exist */
 
+	    ACPI_MOVE_32_TO_32(&TmpName, &Arg->Named.Name);
+            Status = AcpiNsLookup (WalkState->ScopeInfo,
+                (char *) &TmpName, Info->FieldType,
+                ACPI_IMODE_EXECUTE, ACPI_NS_DONT_OPEN_SCOPE,
+                WalkState, &Info->FieldNode);
+	/*
             Status = AcpiNsLookup (WalkState->ScopeInfo,
                 (char *) &Arg->Named.Name, Info->FieldType,
                 ACPI_IMODE_EXECUTE, ACPI_NS_DONT_OPEN_SCOPE,
                 WalkState, &Info->FieldNode);
+	*/
             if (ACPI_FAILURE (Status))
             {
                 ACPI_ERROR_NAMESPACE (WalkState->ScopeInfo,
@@ -689,9 +697,17 @@ AcpiDsInitFieldObjects (
          */
         if (Arg->Common.AmlOpcode == AML_INT_NAMEDFIELD_OP)
         {
+	    UINT32 TmpName;
+
+            ACPI_MOVE_32_TO_32(&TmpName, &Arg->Named.Name);
+            Status = AcpiNsLookup (WalkState->ScopeInfo,
+                (char *) &TmpName, Type, ACPI_IMODE_LOAD_PASS1,
+                Flags, WalkState, &Node);
+	/*
             Status = AcpiNsLookup (WalkState->ScopeInfo,
                 (char *) &Arg->Named.Name, Type, ACPI_IMODE_LOAD_PASS1,
                 Flags, WalkState, &Node);
+	*/
             if (ACPI_FAILURE (Status))
             {
                 ACPI_ERROR_NAMESPACE (WalkState->ScopeInfo,
Index: acpica-unix-20191213/source/components/events/evgpeblk.c
===================================================================
--- acpica-unix-20191213.orig/source/components/events/evgpeblk.c
+++ acpica-unix-20191213/source/components/events/evgpeblk.c
@@ -380,6 +380,7 @@ AcpiEvCreateGpeBlock (
     ACPI_STATUS             Status;
     ACPI_GPE_BLOCK_INFO     *GpeBlock;
     ACPI_GPE_WALK_INFO      WalkInfo;
+    char		    Name[ACPI_NAMESEG_SIZE + 1];
 
 
     ACPI_FUNCTION_TRACE (EvCreateGpeBlock);
@@ -400,7 +401,7 @@ AcpiEvCreateGpeBlock (
 
     /* Initialize the new GPE block */
 
-    GpeBlock->Address = Address;
+    ACPI_MOVE_64_TO_64(&GpeBlock->Address, &Address);
     GpeBlock->SpaceId = SpaceId;
     GpeBlock->Node = GpeDevice;
     GpeBlock->GpeCount = (UINT16) (RegisterCount * ACPI_GPE_REGISTER_WIDTH);
@@ -449,11 +450,13 @@ AcpiEvCreateGpeBlock (
         (*ReturnGpeBlock) = GpeBlock;
     }
 
+    memset(&Name, 0, ACPI_NAMESEG_SIZE + 1);
+    ACPI_MOVE_32_TO_32(&Name, &GpeDevice->Name.Ascii);
     ACPI_DEBUG_PRINT_RAW ((ACPI_DB_INIT,
         "    Initialized GPE %02X to %02X [%4.4s] %u regs on interrupt 0x%X%s\n",
         (UINT32) GpeBlock->BlockBaseNumber,
         (UINT32) (GpeBlock->BlockBaseNumber + (GpeBlock->GpeCount - 1)),
-        GpeDevice->Name.Ascii, GpeBlock->RegisterCount, InterruptNumber,
+        Name, GpeBlock->RegisterCount, InterruptNumber,
         InterruptNumber == AcpiGbl_FADT.SciInterrupt ? " (SCI)" : ""));
 
     /* Update global count of currently available GPEs */
Index: acpica-unix-20191213/source/components/hardware/hwregs.c
===================================================================
--- acpica-unix-20191213.orig/source/components/hardware/hwregs.c
+++ acpica-unix-20191213/source/components/hardware/hwregs.c
@@ -197,7 +197,7 @@ AcpiHwValidateRegister (
      * Address must not be null. A null address also indicates an optional
      * ACPI register that is not supported, so no error message.
      */
-    ACPI_MOVE_64_TO_64 (Address, &Reg->Address);
+    *Address =  Reg->Address;
     if (!(*Address))
     {
         return (AE_BAD_ADDRESS);
Index: acpica-unix-20191213/source/components/hardware/hwvalid.c
===================================================================
--- acpica-unix-20191213.orig/source/components/hardware/hwvalid.c
+++ acpica-unix-20191213/source/components/hardware/hwvalid.c
@@ -135,6 +135,8 @@ AcpiHwValidateIoRequest (
     UINT32                  ByteWidth;
     ACPI_IO_ADDRESS         LastAddress;
     const ACPI_PORT_INFO    *PortInfo;
+    UINT64                  Max16;
+    UINT64                  Tmp64;
 
 
     ACPI_FUNCTION_TRACE (HwValidateIoRequest);
@@ -162,7 +164,10 @@ AcpiHwValidateIoRequest (
 
     /* Maximum 16-bit address in I/O space */
 
-    if (LastAddress > ACPI_UINT16_MAX)
+    Max16 = (UINT64) ACPI_UINT16_MAX;
+    ACPI_MOVE_64_TO_64(&Tmp64, &Max16);
+
+    if ((UINT64)LastAddress > Tmp64)
     {
         ACPI_ERROR ((AE_INFO,
             "Illegal I/O port address/length above 64K: %8.8X%8.8X/0x%X",
Index: acpica-unix-20191213/source/components/namespace/nsaccess.c
===================================================================
--- acpica-unix-20191213.orig/source/components/namespace/nsaccess.c
+++ acpica-unix-20191213/source/components/namespace/nsaccess.c
@@ -349,6 +349,7 @@ AcpiNsLookup (
     UINT32                  SearchParentFlag = ACPI_NS_SEARCH_PARENT;
     UINT32                  LocalFlags;
     ACPI_INTERPRETER_MODE   LocalInterpreterMode;
+    UINT32		    Tmp32;
 
 
     ACPI_FUNCTION_TRACE (NsLookup);
@@ -758,9 +759,10 @@ AcpiNsLookup (
             {
                 /* Complain about a type mismatch */
 
+		ACPI_MOVE_32_TO_32(&Tmp32, &SimpleName);
                 ACPI_WARNING ((AE_INFO,
                     "NsLookup: Type mismatch on %4.4s (%s), searching for (%s)",
-                    ACPI_CAST_PTR (char, &SimpleName),
+                    ACPI_CAST_PTR (char, &Tmp32),
                     AcpiUtGetTypeName (ThisNode->Type),
                     AcpiUtGetTypeName (TypeToCheckFor)));
             }
Index: acpica-unix-20191213/source/components/namespace/nsparse.c
===================================================================
--- acpica-unix-20191213.orig/source/components/namespace/nsparse.c
+++ acpica-unix-20191213/source/components/namespace/nsparse.c
@@ -216,13 +216,14 @@ AcpiNsOneCompleteParse (
 
     /* Table must consist of at least a complete header */
 
-    if (Table->Length < sizeof (ACPI_TABLE_HEADER))
+    ACPI_MOVE_32_TO_32(&AmlLength, &Table->Length);
+    if (AmlLength < sizeof (ACPI_TABLE_HEADER))
     {
         return_ACPI_STATUS (AE_BAD_HEADER);
     }
 
     AmlStart = (UINT8 *) Table + sizeof (ACPI_TABLE_HEADER);
-    AmlLength = Table->Length - sizeof (ACPI_TABLE_HEADER);
+    AmlLength -= sizeof (ACPI_TABLE_HEADER);
 
     Status = AcpiTbGetOwnerId (TableIndex, &OwnerId);
     if (ACPI_FAILURE (Status))
Index: acpica-unix-20191213/source/components/tables/tbdata.c
===================================================================
--- acpica-unix-20191213.orig/source/components/tables/tbdata.c
+++ acpica-unix-20191213/source/components/tables/tbdata.c
@@ -552,6 +552,7 @@ AcpiTbVerifyTempTable (
     UINT32                  *TableIndex)
 {
     ACPI_STATUS             Status = AE_OK;
+    UINT32		    Length;
 
 
     ACPI_FUNCTION_TRACE (TbVerifyTempTable);
@@ -581,7 +582,8 @@ AcpiTbVerifyTempTable (
     {
         /* Verify the checksum */
 
-        Status = AcpiTbVerifyChecksum (TableDesc->Pointer, TableDesc->Length);
+        ACPI_MOVE_32_TO_32(&Length, &TableDesc->Length);
+        Status = AcpiTbVerifyChecksum (TableDesc->Pointer, Length);
         if (ACPI_FAILURE (Status))
         {
             ACPI_EXCEPTION ((AE_INFO, AE_NO_MEMORY,
Index: acpica-unix-20191213/source/components/tables/tbfadt.c
===================================================================
--- acpica-unix-20191213.orig/source/components/tables/tbfadt.c
+++ acpica-unix-20191213/source/components/tables/tbfadt.c
@@ -424,18 +424,20 @@ AcpiTbCreateLocalFadt (
     ACPI_TABLE_HEADER       *Table,
     UINT32                  Length)
 {
+    UINT32 Tmp32;
 
     /*
      * Check if the FADT is larger than the largest table that we expect
      * (typically the current ACPI specification version). If so, truncate
      * the table, and issue a warning.
      */
-    if (Length > sizeof (ACPI_TABLE_FADT))
+    ACPI_MOVE_32_TO_32(&Tmp32, &Length);
+    if (Tmp32 > sizeof (ACPI_TABLE_FADT))
     {
         ACPI_BIOS_WARNING ((AE_INFO,
             "FADT (revision %u) is longer than %s length, "
             "truncating length %u to %u",
-            Table->Revision, ACPI_FADT_CONFORMANCE, Length,
+            Table->Revision, ACPI_FADT_CONFORMANCE, Tmp32,
             (UINT32) sizeof (ACPI_TABLE_FADT)));
     }
 
@@ -446,7 +448,7 @@ AcpiTbCreateLocalFadt (
     /* Copy the original FADT, up to sizeof (ACPI_TABLE_FADT) */
 
     memcpy (&AcpiGbl_FADT, Table,
-        ACPI_MIN (Length, sizeof (ACPI_TABLE_FADT)));
+        ACPI_MIN (Tmp32, sizeof (ACPI_TABLE_FADT)));
 
     /* Take a copy of the Hardware Reduced flag */
 
@@ -520,6 +522,8 @@ AcpiTbConvertFadt (
     UINT8                   Length;
     UINT8                   Flags;
     UINT32                  i;
+    UINT32		    Tmp32;
+    UINT64		    Tmp64;
 
 
     /*
@@ -533,7 +537,8 @@ AcpiTbConvertFadt (
      * Note: The FADT revision value is unreliable. Only the length can be
      * trusted.
      */
-    if (AcpiGbl_FADT.Header.Length <= ACPI_FADT_V2_SIZE)
+    ACPI_MOVE_32_TO_32(&Tmp32, &AcpiGbl_FADT.Header.Length);
+    if (Tmp32 <= ACPI_FADT_V2_SIZE)
     {
         AcpiGbl_FADT.PreferredProfile = 0;
         AcpiGbl_FADT.PstateControl = 0;
@@ -546,14 +551,15 @@ AcpiTbConvertFadt (
      * current FADT version as defined by the ACPI specification.
      * Thus, we will have a common FADT internally.
      */
-    AcpiGbl_FADT.Header.Length = sizeof (ACPI_TABLE_FADT);
+    Tmp32 = sizeof (ACPI_TABLE_FADT);
+    ACPI_MOVE_32_TO_32(&AcpiGbl_FADT.Header.Length, &Tmp32);
 
     /*
      * Expand the 32-bit DSDT addresses to 64-bit as necessary.
      * Later ACPICA code will always use the X 64-bit field.
      */
-    AcpiGbl_FADT.XDsdt = AcpiTbSelectAddress ("DSDT",
-        AcpiGbl_FADT.Dsdt, AcpiGbl_FADT.XDsdt);
+    Tmp64 = AcpiTbSelectAddress ("DSDT", AcpiGbl_FADT.Dsdt, AcpiGbl_FADT.XDsdt);
+    ACPI_MOVE_64_TO_64(&AcpiGbl_FADT.XDsdt, &Tmp64);
 
     /* If Hardware Reduced flag is set, we are all done */
 
@@ -614,7 +620,9 @@ AcpiTbConvertFadt (
         {
             if (Address64->Address)
             {
-                if (Address64->Address != (UINT64) Address32)
+		ACPI_MOVE_32_TO_32(&Tmp32, &Address32);
+		ACPI_MOVE_64_TO_64(&Tmp64, &Address64->Address);
+                if (Tmp64 != (UINT64) Tmp32)
                 {
                     /* Address mismatch */
 
@@ -655,9 +663,11 @@ AcpiTbConvertFadt (
              */
             if (!Address64->Address || AcpiGbl_Use32BitFadtAddresses)
             {
+		ACPI_MOVE_32_TO_32(&Tmp32, &Address32); /* back to host order */
+		Tmp64 = (UINT64) Tmp32;			/* promote only */
                 AcpiTbInitGenericAddress (Address64,
                     ACPI_ADR_SPACE_SYSTEM_IO, Length,
-                    (UINT64) Address32, Name, Flags);
+                    Tmp64, Name, Flags);
             }
         }
 
@@ -780,10 +790,14 @@ AcpiTbSetupFadtRegisters (
 
         if (Source64->Address)
         {
+	    UINT64 Tmp64, Addr64;
+
+	    ACPI_MOVE_64_TO_64(&Tmp64, &Source64->Address);
+	    Tmp64 += (FadtPmInfoTable[i].RegisterNum * Pm1RegisterByteWidth);
+	    ACPI_MOVE_64_TO_64(&Addr64, &Tmp64);
             AcpiTbInitGenericAddress (FadtPmInfoTable[i].Target,
                 Source64->SpaceId, Pm1RegisterByteWidth,
-                Source64->Address +
-                    (FadtPmInfoTable[i].RegisterNum * Pm1RegisterByteWidth),
+                Addr64,
                 "PmRegisters", 0);
         }
     }
Index: acpica-unix-20191213/source/components/tables/tbfind.c
===================================================================
--- acpica-unix-20191213.orig/source/components/tables/tbfind.c
+++ acpica-unix-20191213/source/components/tables/tbfind.c
@@ -108,8 +108,11 @@ AcpiTbFindTable (
     (void) AcpiUtAcquireMutex (ACPI_MTX_TABLES);
     for (i = 0; i < AcpiGbl_RootTableList.CurrentTableCount; ++i)
     {
+        UINT32 Tmp32;
+
+        ACPI_MOVE_32_TO_32(&Tmp32, &Header.Signature);
         if (memcmp (&(AcpiGbl_RootTableList.Tables[i].Signature),
-            Header.Signature, ACPI_NAMESEG_SIZE))
+            &Tmp32, ACPI_NAMESEG_SIZE))
         {
             /* Not the requested table */
 
Index: acpica-unix-20191213/source/components/tables/tbprint.c
===================================================================
--- acpica-unix-20191213.orig/source/components/tables/tbprint.c
+++ acpica-unix-20191213/source/components/tables/tbprint.c
@@ -143,15 +143,18 @@ AcpiTbPrintTableHeader (
     ACPI_TABLE_HEADER       *Header)
 {
     ACPI_TABLE_HEADER       LocalHeader;
+    UINT32		    Len;
+    UINT32		    OemRev;
+    UINT32		    CompilerRev;
 
 
     if (ACPI_COMPARE_NAMESEG (Header->Signature, ACPI_SIG_FACS))
     {
         /* FACS only has signature and length fields */
 
+	ACPI_MOVE_32_TO_32(&Len, &Header->Length);
         ACPI_INFO (("%-4.4s 0x%8.8X%8.8X %06X",
-            Header->Signature, ACPI_FORMAT_UINT64 (Address),
-            Header->Length));
+            Header->Signature, ACPI_FORMAT_UINT64 (Address), Len));
     }
     else if (ACPI_VALIDATE_RSDP_SIG (Header->Signature))
     {
@@ -174,13 +177,16 @@ AcpiTbPrintTableHeader (
 
         AcpiTbCleanupTableHeader (&LocalHeader, Header);
 
+	ACPI_MOVE_32_TO_32(&Len, &LocalHeader.Length);
+	ACPI_MOVE_32_TO_32(&OemRev, &LocalHeader.OemRevision);
+	ACPI_MOVE_32_TO_32(&CompilerRev, &LocalHeader.AslCompilerRevision);
         ACPI_INFO ((
             "%-4.4s 0x%8.8X%8.8X"
             " %06X (v%.2d %-6.6s %-8.8s %08X %-4.4s %08X)",
             LocalHeader.Signature, ACPI_FORMAT_UINT64 (Address),
-            LocalHeader.Length, LocalHeader.Revision, LocalHeader.OemId,
-            LocalHeader.OemTableId, LocalHeader.OemRevision,
-            LocalHeader.AslCompilerId, LocalHeader.AslCompilerRevision));
+            Len, LocalHeader.Revision, LocalHeader.OemId,
+            LocalHeader.OemTableId, OemRev,
+            LocalHeader.AslCompilerId, CompilerRev));
     }
 }
 
Index: acpica-unix-20191213/source/components/tables/tbutils.c
===================================================================
--- acpica-unix-20191213.orig/source/components/tables/tbutils.c
+++ acpica-unix-20191213/source/components/tables/tbutils.c
@@ -238,7 +238,7 @@ AcpiTbGetRootTableEntry (
          * 64-bit platform, XSDT: Move (unaligned) 64-bit to local,
          *  return 64-bit
          */
-        ACPI_MOVE_64_TO_64 (&Address64, TableEntry);
+	Address64 = (UINT64) TableEntry;
 
 #if ACPI_MACHINE_WIDTH == 32
         if (Address64 > ACPI_UINT32_MAX)
@@ -251,7 +251,8 @@ AcpiTbGetRootTableEntry (
                 ACPI_FORMAT_UINT64 (Address64)));
         }
 #endif
-        return ((ACPI_PHYSICAL_ADDRESS) (Address64));
+        return ((ACPI_PHYSICAL_ADDRESS) (*ACPI_CAST_PTR (
+            UINT64, Address64)));
     }
 }
 
@@ -287,6 +288,7 @@ AcpiTbParseRootTable (
     UINT8                   *TableEntry;
     ACPI_STATUS             Status;
     UINT32                  TableIndex;
+    UINT32                  Tmp32;
 
 
     ACPI_FUNCTION_TRACE (TbParseRootTable);
@@ -345,7 +347,7 @@ AcpiTbParseRootTable (
      * Validate length of the table, and map entire table.
      * Minimum length table must contain at least one entry.
      */
-    Length = Table->Length;
+    ACPI_MOVE_32_TO_32(&Length, &Table->Length);
     AcpiOsUnmapMemory (Table, sizeof (ACPI_TABLE_HEADER));
 
     if (Length < (sizeof (ACPI_TABLE_HEADER) + TableEntrySize))
@@ -372,7 +374,7 @@ AcpiTbParseRootTable (
 
     /* Get the number of entries and pointer to first entry */
 
-    TableCount = (UINT32) ((Table->Length - sizeof (ACPI_TABLE_HEADER)) /
+    TableCount = (UINT32) ((Length - sizeof (ACPI_TABLE_HEADER)) /
         TableEntrySize);
     TableEntry = ACPI_ADD_PTR (UINT8, Table, sizeof (ACPI_TABLE_HEADER));
 
@@ -394,10 +396,10 @@ AcpiTbParseRootTable (
         Status = AcpiTbInstallStandardTable (Address,
             ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL, FALSE, TRUE, &TableIndex);
 
+	ACPI_MOVE_32_TO_32(&Tmp32,
+			   &AcpiGbl_RootTableList.Tables[TableIndex].Signature);
         if (ACPI_SUCCESS (Status) &&
-            ACPI_COMPARE_NAMESEG (
-                &AcpiGbl_RootTableList.Tables[TableIndex].Signature,
-                ACPI_SIG_FADT))
+            ACPI_COMPARE_NAMESEG (&Tmp32, ACPI_SIG_FADT))
         {
             AcpiGbl_FadtIndex = TableIndex;
             AcpiTbParseFadt ();
Index: acpica-unix-20191213/source/components/tables/tbxface.c
===================================================================
--- acpica-unix-20191213.orig/source/components/tables/tbxface.c
+++ acpica-unix-20191213/source/components/tables/tbxface.c
@@ -293,8 +293,11 @@ AcpiGetTableHeader (
 
     for (i = 0, j = 0; i < AcpiGbl_RootTableList.CurrentTableCount; i++)
     {
+	UINT32 Tmp32;
+
+	ACPI_MOVE_32_TO_32(&Tmp32, (UINT32 *)Signature);
         if (!ACPI_COMPARE_NAMESEG (
-                &(AcpiGbl_RootTableList.Tables[i].Signature), Signature))
+                &(AcpiGbl_RootTableList.Tables[i].Signature), &Tmp32))
         {
             continue;
         }
Index: acpica-unix-20191213/source/components/tables/tbxfload.c
===================================================================
--- acpica-unix-20191213.orig/source/components/tables/tbxfload.c
+++ acpica-unix-20191213/source/components/tables/tbxfload.c
@@ -153,6 +153,7 @@ AcpiTbLoadNamespace (
     ACPI_TABLE_DESC         *Table;
     UINT32                  TablesLoaded = 0;
     UINT32                  TablesFailed = 0;
+    UINT32		    Tmp32;
 
 
     ACPI_FUNCTION_TRACE (TbLoadNamespace);
@@ -166,8 +167,9 @@ AcpiTbLoadNamespace (
      */
     Table = &AcpiGbl_RootTableList.Tables[AcpiGbl_DsdtIndex];
 
+    ACPI_MOVE_32_TO_32(&Tmp32, &Table->Signature.Ascii);
     if (!AcpiGbl_RootTableList.CurrentTableCount ||
-        !ACPI_COMPARE_NAMESEG (Table->Signature.Ascii, ACPI_SIG_DSDT) ||
+        !ACPI_COMPARE_NAMESEG (&Tmp32, ACPI_SIG_DSDT) ||
          ACPI_FAILURE (AcpiTbValidateTable (Table)))
     {
         Status = AE_NO_ACPI_TABLES;
Index: acpica-unix-20191213/source/tools/acpiexec/aetables.c
===================================================================
--- acpica-unix-20191213.orig/source/tools/acpiexec/aetables.c
+++ acpica-unix-20191213/source/tools/acpiexec/aetables.c
@@ -146,21 +146,25 @@ AeInitializeTableHeader (
     char                    *Signature,
     UINT32                  Length)
 {
+    UINT16		    Tmp16;
+    UINT32		    Tmp32;
 
     ACPI_COPY_NAMESEG (Header->Signature, Signature);
-    Header->Length = Length;
+    ACPI_MOVE_32_TO_32(&Header->Length, &Length);
 
-    Header->OemRevision = 0x1001;
+    Tmp16 = 0x1001;
+    ACPI_MOVE_16_TO_16(&Header->OemRevision, &Tmp16);
     memcpy (Header->OemId, "Intel ", ACPI_OEM_ID_SIZE);
     memcpy (Header->OemTableId, "AcpiExec", ACPI_OEM_TABLE_ID_SIZE);
     ACPI_COPY_NAMESEG (Header->AslCompilerId, "INTL");
-    Header->AslCompilerRevision = ACPI_CA_VERSION;
+    Tmp32 = ACPI_CA_VERSION;
+    ACPI_MOVE_32_TO_32(&Header->AslCompilerRevision, &Tmp32);
 
     /* Set the checksum, must set to zero first */
 
     Header->Checksum = 0;
     Header->Checksum = (UINT8) -AcpiTbChecksum (
-        (void *) Header, Header->Length);
+        (void *) Header, Length);
 }
 
 
@@ -188,6 +192,7 @@ AeBuildLocalTables (
     ACPI_NEW_TABLE_DESC     *NextTable;
     UINT32                  NextIndex;
     ACPI_TABLE_FADT         *ExternalFadt = NULL;
+    UINT32		    Tmp32;
 
 
     /*
@@ -374,6 +379,8 @@ AeBuildLocalTables (
     }
     else
     {
+        UINT64		    Tmp64;
+
         /*
          * Build a local FADT so we can test the hardware/event init
          */
@@ -385,34 +392,44 @@ AeBuildLocalTables (
         LocalFADT.Facs = 0;
 
         LocalFADT.XDsdt = DsdtAddress;
-        LocalFADT.XFacs = ACPI_PTR_TO_PHYSADDR (&LocalFACS);
+        Tmp64 = ACPI_PTR_TO_PHYSADDR (&LocalFACS);
+        ACPI_MOVE_64_TO_64(&LocalFADT.XFacs, &Tmp64);
 
         /* Miscellaneous FADT fields */
 
         LocalFADT.Gpe0BlockLength = 0x20;
-        LocalFADT.Gpe0Block = 0x00003210;
+        Tmp32 = 0x00003210;
+        ACPI_MOVE_32_TO_32(&LocalFADT.Gpe0Block, &Tmp32);
 
         LocalFADT.Gpe1BlockLength = 0x20;
-        LocalFADT.Gpe1Block = 0x0000BA98;
+        Tmp32 = 0x0000BA98;
+        ACPI_MOVE_32_TO_32(&LocalFADT.Gpe1Block, &Tmp32);
         LocalFADT.Gpe1Base = 0x80;
 
         LocalFADT.Pm1EventLength = 4;
-        LocalFADT.Pm1aEventBlock = 0x00001aaa;
-        LocalFADT.Pm1bEventBlock = 0x00001bbb;
+        Tmp32 = 0x00001aaa;
+        ACPI_MOVE_32_TO_32(&LocalFADT.Pm1aEventBlock, &Tmp32);
+        Tmp32 = 0x00001bbb;
+        ACPI_MOVE_32_TO_32(&LocalFADT.Pm1bEventBlock, &Tmp32);
 
         LocalFADT.Pm1ControlLength = 2;
-        LocalFADT.Pm1aControlBlock = 0xB0;
+        Tmp32 = 0xB0;
+        ACPI_MOVE_32_TO_32(&LocalFADT.Pm1aControlBlock, &Tmp32);
 
         LocalFADT.PmTimerLength = 4;
-        LocalFADT.PmTimerBlock = 0xA0;
+        Tmp32 = 0xA0;
+        ACPI_MOVE_32_TO_32(&LocalFADT.PmTimerBlock, &Tmp32);
 
-        LocalFADT.Pm2ControlBlock = 0xC0;
+        Tmp32 = 0xC0;
+        ACPI_MOVE_32_TO_32(&LocalFADT.Pm2ControlBlock, &Tmp32);
         LocalFADT.Pm2ControlLength = 1;
 
         /* Setup one example X-64 GAS field */
 
         LocalFADT.XPm1bEventBlock.SpaceId = ACPI_ADR_SPACE_SYSTEM_IO;
-        LocalFADT.XPm1bEventBlock.Address = LocalFADT.Pm1bEventBlock;
+	ACPI_MOVE_32_TO_32(&Tmp32, &LocalFADT.Pm1bEventBlock);
+	Tmp64 = (UINT64)Tmp32;
+        ACPI_MOVE_64_TO_64(&LocalFADT.XPm1bEventBlock.Address, &Tmp64);
         LocalFADT.XPm1bEventBlock.BitWidth = (UINT8)
             ACPI_MUL_8 (LocalFADT.Pm1EventLength);
     }
@@ -425,13 +442,17 @@ AeBuildLocalTables (
     memset (&LocalFACS, 0, sizeof (ACPI_TABLE_FACS));
     ACPI_COPY_NAMESEG (LocalFACS.Signature, ACPI_SIG_FACS);
 
-    LocalFACS.Length = sizeof (ACPI_TABLE_FACS);
-    LocalFACS.GlobalLock = 0x11AA0011;
+    Tmp32 = sizeof (ACPI_TABLE_FACS);
+    ACPI_MOVE_32_TO_32(&LocalFACS.Length, &Tmp32);
+    Tmp32 = 0x11AA0011;
+    ACPI_MOVE_32_TO_32(&LocalFACS.GlobalLock, &Tmp32);
 
     /* Build the optional local tables */
 
     if (AcpiGbl_LoadTestTables)
     {
+	UINT32 Tmp32;
+
         /*
          * Build a fake table [TEST] so that we make sure that the
          * ACPICA core ignores it
@@ -440,11 +461,12 @@ AeBuildLocalTables (
         ACPI_COPY_NAMESEG (LocalTEST.Signature, "TEST");
 
         LocalTEST.Revision = 1;
-        LocalTEST.Length = sizeof (ACPI_TABLE_HEADER);
+        Tmp32 = sizeof (ACPI_TABLE_HEADER);
+        ACPI_MOVE_32_TO_32(&LocalTEST.Length, &Tmp32);
 
         LocalTEST.Checksum = 0;
         LocalTEST.Checksum = (UINT8) -AcpiTbChecksum (
-            (void *) &LocalTEST, LocalTEST.Length);
+            (void *) &LocalTEST, Tmp32);
 
         /*
          * Build a fake table with a bad signature [BAD!] so that we make
@@ -454,11 +476,12 @@ AeBuildLocalTables (
         ACPI_COPY_NAMESEG (LocalBADTABLE.Signature, "BAD!");
 
         LocalBADTABLE.Revision = 1;
-        LocalBADTABLE.Length = sizeof (ACPI_TABLE_HEADER);
+        Tmp32 = sizeof (ACPI_TABLE_HEADER);
+        ACPI_MOVE_32_TO_32(&LocalBADTABLE.Length, &Tmp32);
 
         LocalBADTABLE.Checksum = 0;
         LocalBADTABLE.Checksum = (UINT8) -AcpiTbChecksum (
-            (void *) &LocalBADTABLE, LocalBADTABLE.Length);
+            (void *) &LocalBADTABLE, Tmp32);
     }
 
     return (AE_OK);
Index: acpica-unix-20191213/source/common/dmswitch.c
===================================================================
--- acpica-unix-20191213.orig/source/common/dmswitch.c
+++ acpica-unix-20191213/source/common/dmswitch.c
@@ -88,13 +88,15 @@ AcpiDmProcessSwitch (
     ACPI_PARSE_OBJECT_LIST  *Current;
     ACPI_PARSE_OBJECT_LIST  *Previous;
     BOOLEAN                 FoundTemp = FALSE;
+    UINT32		    Tmp32;
 
 
     switch (Op->Common.AmlOpcode)
     {
     case AML_NAME_OP:
 
-        Temp = (char *) (&Op->Named.Name);
+	ACPI_MOVE_32_TO_32(&Tmp32, &Op->Named.Name);
+        Temp = (char *) (&Tmp32);
 
         if (!strncmp(Temp, "_T_", 3))
         {
@@ -138,7 +140,10 @@ AcpiDmProcessSwitch (
         {
             /* Note, if we get here Temp is not NULL */
 
-            if (!strncmp(Temp, (char *) (&Current->Op->Named.Name), 4))
+   	    ACPI_MOVE_32_TO_32(&Tmp32, &Current->Op->Named.Name);
+
+            /* if (!strncmp(Temp, (char *) (&Current->Op->Named.Name), 4)) */
+            if (!strncmp(Temp, (char *) &Tmp32, 4))
             {
                 /* Match found. Ignore disassembly */
 
